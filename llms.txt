This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.github/
  workflows/
    ci.yml
docs/
  _static/
    .gitignore
  authors.md
  changelog.md
  conf.py
  contributing.md
  index.md
  license.md
  Makefile
  readme.md
  requirements.txt
src/
  svg_removeoverlap/
    __init__.py
    __main__.py
    remover.py
tests/
  fixtures/
    no_overlap.svg
    simple_overlap.svg
    with_white.svg
  conftest.py
  test_cli.py
  test_integration.py
  test_remover.py
.coveragerc
.gitignore
.isort.cfg
.pre-commit-config.yaml
.readthedocs.yml
AUTHORS.md
LICENSE.txt
mypy.ini
pyproject.toml
README.md
setup.cfg
setup.py
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path=".github/workflows/ci.yml">
# GitHub Actions configuration **EXAMPLE**,
# MODIFY IT ACCORDING TO YOUR NEEDS!
# Reference: https://docs.github.com/en/actions

name: tests

on:
  push:
    # Avoid using all the resources/limits available by checking only
    # relevant branches and tags. Other branches can be checked via PRs.
    branches: [main]
    tags: ['v[0-9]*', '[0-9]+.[0-9]+*']  # Match tags that resemble a version
  pull_request:  # Run in every PR
  workflow_dispatch:  # Allow manually triggering the workflow
  schedule:
    # Run roughly every 15 days at 00:00 UTC
    # (useful to check if updates on dependencies break the package)
    - cron: '0 0 1,16 * *'

concurrency:
  group: >-
    ${{ github.workflow }}-${{ github.ref_type }}-
    ${{ github.event.pull_request.number || github.sha }}
  cancel-in-progress: true

jobs:
  prepare:
    runs-on: ubuntu-latest
    outputs:
      wheel-distribution: ${{ steps.wheel-distribution.outputs.path }}
    steps:
      - uses: actions/checkout@v3
        with: {fetch-depth: 0}  # deep clone for setuptools-scm
      - uses: actions/setup-python@v4
        id: setup-python
        with: {python-version: "3.11"}  # Use a recent Python for these steps
      - name: Run static analysis and format checkers
        run: pipx run pre-commit run --all-files --show-diff-on-failure
      - name: Build package distribution files
        run: >-
          pipx run --python '${{ steps.setup-python.outputs.python-path }}'
          tox -e clean,build
      - name: Record the path of wheel distribution
        id: wheel-distribution
        run: echo "path=$(ls dist/*.whl)" >> $GITHUB_OUTPUT
      - name: Store the distribution files for use in other stages
        # `tests` and `publish` will use the same pre-built distributions,
        # so we make sure to release the exact same package that was tested
        uses: actions/upload-artifact@v3
        with:
          name: python-distribution-files
          path: dist/
          retention-days: 1

  test:
    needs: prepare
    strategy:
      matrix:
        python:
        - "3.8"
        - "3.9"
        - "3.10"
        - "3.11"
        - "3.12"
        platform:
        - ubuntu-latest
        - macos-latest
        - windows-latest
    runs-on: ${{ matrix.platform }}
    steps:
      - uses: actions/checkout@v3
      - uses: actions/setup-python@v4
        id: setup-python
        with:
          python-version: ${{ matrix.python }}
      - name: Retrieve pre-built distribution files
        uses: actions/download-artifact@v3
        with: {name: python-distribution-files, path: dist/}
      - name: Run tests
        run: >-
          pipx run --python '${{ steps.setup-python.outputs.python-path }}'
          tox --installpkg '${{ needs.prepare.outputs.wheel-distribution }}'
          -- -rFEx --durations 10 --color yes  # pytest args
      - name: Generate coverage report
        run: pipx run coverage lcov -o coverage.lcov
      - name: Upload partial coverage report
        uses: coverallsapp/github-action@master
        with:
          path-to-lcov: coverage.lcov
          github-token: ${{ secrets.github_token }}
          flag-name: ${{ matrix.platform }} - py${{ matrix.python }}
          parallel: true

  finalize:
    needs: test
    runs-on: ubuntu-latest
    steps:
      - name: Finalize coverage report
        uses: coverallsapp/github-action@master
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          parallel-finished: true

  publish:
    needs: finalize
    if: ${{ github.event_name == 'push' && contains(github.ref, 'refs/tags/') }}
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - uses: actions/setup-python@v4
        with: {python-version: "3.11"}  # Use a recent Python for publishing
      - name: Retrieve pre-built distribution files
        uses: actions/download-artifact@v3
        with: {name: python-distribution-files, path: dist/}
      - name: Publish Package
        env:
          # TODO: Set your PYPI_TOKEN as a secret using GitHub UI
          # - https://pypi.org/help/#apitoken
          # - https://docs.github.com/en/actions/security-guides/encrypted-secrets
          TWINE_REPOSITORY: pypi
          TWINE_USERNAME: __token__
          TWINE_PASSWORD: ${{ secrets.PYPI_TOKEN }}
        run: pipx run tox -e publish
</file>

<file path="docs/_static/.gitignore">
# Empty directory
</file>

<file path="docs/authors.md">
```{include} ../AUTHORS.md
:relative-docs: docs/
:relative-images:
```
</file>

<file path="docs/changelog.md">
```{include} ../CHANGELOG.md
:relative-docs: docs/
:relative-images:
```
</file>

<file path="docs/conf.py">
# This file is execfile()d with the current directory set to its containing dir.
#
# This file only contains a selection of the most common options. For a full
# list see the documentation:
# https://www.sphinx-doc.org/en/master/usage/configuration.html
#
# All configuration values have a default; values that are commented out
# serve to show the default.

import os
import sys
import shutil

# -- Path setup --------------------------------------------------------------

__location__ = os.path.dirname(__file__)

# If extensions (or modules to document with autodoc) are in another directory,
# add these directories to sys.path here. If the directory is relative to the
# documentation root, use os.path.abspath to make it absolute, like shown here.
sys.path.insert(0, os.path.join(__location__, "../src"))

# -- Run sphinx-apidoc -------------------------------------------------------
# This hack is necessary since RTD does not issue `sphinx-apidoc` before running
# `sphinx-build -b html . _build/html`. See Issue:
# https://github.com/readthedocs/readthedocs.org/issues/1139
# DON'T FORGET: Check the box "Install your project inside a virtualenv using
# setup.py install" in the RTD Advanced Settings.
# Additionally it helps us to avoid running apidoc manually

try:  # for Sphinx >= 1.7
    from sphinx.ext import apidoc
except ImportError:
    from sphinx import apidoc

output_dir = os.path.join(__location__, "api")
module_dir = os.path.join(__location__, "../src/svg_removeoverlap")
try:
    shutil.rmtree(output_dir)
except FileNotFoundError:
    pass

try:
    import sphinx

    cmd_line = f"sphinx-apidoc --implicit-namespaces -f -o {output_dir} {module_dir}"

    args = cmd_line.split(" ")
    if tuple(sphinx.__version__.split(".")) >= ("1", "7"):
        # This is a rudimentary parse_version to avoid external dependencies
        args = args[1:]

    apidoc.main(args)
except Exception as e:
    print("Running `sphinx-apidoc` failed!\n{}".format(e))

# -- General configuration ---------------------------------------------------

# If your documentation needs a minimal Sphinx version, state it here.
# needs_sphinx = '1.0'

# Add any Sphinx extension module names here, as strings. They can be extensions
# coming with Sphinx (named 'sphinx.ext.*') or your custom ones.
extensions = [
    "sphinx.ext.autodoc",
    "sphinx.ext.intersphinx",
    "sphinx.ext.todo",
    "sphinx.ext.autosummary",
    "sphinx.ext.viewcode",
    "sphinx.ext.coverage",
    "sphinx.ext.doctest",
    "sphinx.ext.ifconfig",
    "sphinx.ext.mathjax",
    "sphinx.ext.napoleon",
]

# Add any paths that contain templates here, relative to this directory.
templates_path = ["_templates"]


# Enable markdown
extensions.append("myst_parser")

# Configure MyST-Parser
myst_enable_extensions = [
    "amsmath",
    "colon_fence",
    "deflist",
    "dollarmath",
    "html_image",
    "linkify",
    "replacements",
    "smartquotes",
    "substitution",
    "tasklist",
]

# The suffix of source filenames.
source_suffix = [".rst", ".md"]

# The encoding of source files.
# source_encoding = 'utf-8-sig'

# The master toctree document.
master_doc = "index"

# General information about the project.
project = "svg_removeoverlap"
copyright = "2023, twardoch"

# The version info for the project you're documenting, acts as replacement for
# |version| and |release|, also used in various other places throughout the
# built documents.
#
# version: The short X.Y version.
# release: The full version, including alpha/beta/rc tags.
# If you donâ€™t need the separation provided between version and release,
# just set them both to the same value.
try:
    from svg_removeoverlap import __version__ as version
except ImportError:
    version = ""

if not version or version.lower() == "unknown":
    version = os.getenv("READTHEDOCS_VERSION", "unknown")  # automatically set by RTD

release = version

# The language for content autogenerated by Sphinx. Refer to documentation
# for a list of supported languages.
# language = None

# There are two options for replacing |today|: either, you set today to some
# non-false value, then it is used:
# today = ''
# Else, today_fmt is used as the format for a strftime call.
# today_fmt = '%B %d, %Y'

# List of patterns, relative to source directory, that match files and
# directories to ignore when looking for source files.
exclude_patterns = ["_build", "Thumbs.db", ".DS_Store", ".venv"]

# The reST default role (used for this markup: `text`) to use for all documents.
# default_role = None

# If true, '()' will be appended to :func: etc. cross-reference text.
# add_function_parentheses = True

# If true, the current module name will be prepended to all description
# unit titles (such as .. function::).
# add_module_names = True

# If true, sectionauthor and moduleauthor directives will be shown in the
# output. They are ignored by default.
# show_authors = False

# The name of the Pygments (syntax highlighting) style to use.
pygments_style = "sphinx"

# A list of ignored prefixes for module index sorting.
# modindex_common_prefix = []

# If true, keep warnings as "system message" paragraphs in the built documents.
# keep_warnings = False

# If this is True, todo emits a warning for each TODO entries. The default is False.
todo_emit_warnings = True


# -- Options for HTML output -------------------------------------------------

# The theme to use for HTML and HTML Help pages.  See the documentation for
# a list of builtin themes.
html_theme = "alabaster"

# Theme options are theme-specific and customize the look and feel of a theme
# further.  For a list of options available for each theme, see the
# documentation.
html_theme_options = {
    "sidebar_width": "300px",
    "page_width": "1200px"
}

# Add any paths that contain custom themes here, relative to this directory.
# html_theme_path = []

# The name for this set of Sphinx documents.  If None, it defaults to
# "<project> v<release> documentation".
# html_title = None

# A shorter title for the navigation bar.  Default is the same as html_title.
# html_short_title = None

# The name of an image file (relative to this directory) to place at the top
# of the sidebar.
# html_logo = ""

# The name of an image file (within the static path) to use as favicon of the
# docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32
# pixels large.
# html_favicon = None

# Add any paths that contain custom static files (such as style sheets) here,
# relative to this directory. They are copied after the builtin static files,
# so a file named "default.css" will overwrite the builtin "default.css".
html_static_path = ["_static"]

# If not '', a 'Last updated on:' timestamp is inserted at every page bottom,
# using the given strftime format.
# html_last_updated_fmt = '%b %d, %Y'

# If true, SmartyPants will be used to convert quotes and dashes to
# typographically correct entities.
# html_use_smartypants = True

# Custom sidebar templates, maps document names to template names.
# html_sidebars = {}

# Additional templates that should be rendered to pages, maps page names to
# template names.
# html_additional_pages = {}

# If false, no module index is generated.
# html_domain_indices = True

# If false, no index is generated.
# html_use_index = True

# If true, the index is split into individual pages for each letter.
# html_split_index = False

# If true, links to the reST sources are added to the pages.
# html_show_sourcelink = True

# If true, "Created using Sphinx" is shown in the HTML footer. Default is True.
# html_show_sphinx = True

# If true, "(C) Copyright ..." is shown in the HTML footer. Default is True.
# html_show_copyright = True

# If true, an OpenSearch description file will be output, and all pages will
# contain a <link> tag referring to it.  The value of this option must be the
# base URL from which the finished HTML is served.
# html_use_opensearch = ''

# This is the file name suffix for HTML files (e.g. ".xhtml").
# html_file_suffix = None

# Output file base name for HTML help builder.
htmlhelp_basename = "svg_removeoverlap-doc"


# -- Options for LaTeX output ------------------------------------------------

latex_elements = {
    # The paper size ("letterpaper" or "a4paper").
    # "papersize": "letterpaper",
    # The font size ("10pt", "11pt" or "12pt").
    # "pointsize": "10pt",
    # Additional stuff for the LaTeX preamble.
    # "preamble": "",
}

# Grouping the document tree into LaTeX files. List of tuples
# (source start file, target name, title, author, documentclass [howto/manual]).
latex_documents = [
    ("index", "user_guide.tex", "svg_removeoverlap Documentation", "twardoch", "manual")
]

# The name of an image file (relative to this directory) to place at the top of
# the title page.
# latex_logo = ""

# For "manual" documents, if this is true, then toplevel headings are parts,
# not chapters.
# latex_use_parts = False

# If true, show page references after internal links.
# latex_show_pagerefs = False

# If true, show URL addresses after external links.
# latex_show_urls = False

# Documents to append as an appendix to all manuals.
# latex_appendices = []

# If false, no module index is generated.
# latex_domain_indices = True

# -- External mapping --------------------------------------------------------
python_version = ".".join(map(str, sys.version_info[0:2]))
intersphinx_mapping = {
    "sphinx": ("https://www.sphinx-doc.org/en/master", None),
    "python": ("https://docs.python.org/" + python_version, None),
    "matplotlib": ("https://matplotlib.org", None),
    "numpy": ("https://numpy.org/doc/stable", None),
    "sklearn": ("https://scikit-learn.org/stable", None),
    "pandas": ("https://pandas.pydata.org/pandas-docs/stable", None),
    "scipy": ("https://docs.scipy.org/doc/scipy/reference", None),
    "setuptools": ("https://setuptools.pypa.io/en/stable/", None),
    "pyscaffold": ("https://pyscaffold.org/en/stable", None),
}

print(f"loading configurations for {project} {version} ...", file=sys.stderr)
</file>

<file path="docs/contributing.md">
```{include} ../CONTRIBUTING.md
:relative-docs: docs/
:relative-images:
```
</file>

<file path="docs/index.md">
# svg_removeoverlap

CLI tool & Python lib to remove overlap in SVG


## Note

> This is the main page of your project's [Sphinx] documentation. It is
> formatted in [Markdown]. Add additional pages by creating md-files in
> `docs` or rst-files (formatted in [reStructuredText]) and adding links to
> them in the `Contents` section below.
>
> Please check [Sphinx] and [MyST] for more information
> about how to document your project and how to configure your preferences.


## Contents

```{toctree}
:maxdepth: 2

Overview <readme>
Contributions & Help <contributing>
License <license>
Authors <authors>
Changelog <changelog>
Module Reference <api/modules>
```

## Indices and tables

* {ref}`genindex`
* {ref}`modindex`
* {ref}`search`

[Sphinx]: http://www.sphinx-doc.org/
[Markdown]: https://daringfireball.net/projects/markdown/
[reStructuredText]: http://www.sphinx-doc.org/en/master/usage/restructuredtext/basics.html
[MyST]: https://myst-parser.readthedocs.io/en/latest/
</file>

<file path="docs/license.md">
# License

```{literalinclude} ../LICENSE.txt
:language: text
```
</file>

<file path="docs/Makefile">
# Makefile for Sphinx documentation
#

# You can set these variables from the command line, and also
# from the environment for the first two.
SPHINXOPTS    ?=
SPHINXBUILD   ?= sphinx-build
SOURCEDIR     = .
BUILDDIR      = _build
AUTODOCDIR    = api

# User-friendly check for sphinx-build
ifeq ($(shell which $(SPHINXBUILD) >/dev/null 2>&1; echo $?), 1)
$(error "The '$(SPHINXBUILD)' command was not found. Make sure you have Sphinx installed, then set the SPHINXBUILD environment variable to point to the full path of the '$(SPHINXBUILD)' executable. Alternatively you can add the directory with the executable to your PATH. If you don't have Sphinx installed, grab it from https://sphinx-doc.org/")
endif

.PHONY: help clean Makefile

# Put it first so that "make" without argument is like "make help".
help:
	@$(SPHINXBUILD) -M help "$(SOURCEDIR)" "$(BUILDDIR)" $(SPHINXOPTS) $(O)

clean:
	rm -rf $(BUILDDIR)/* $(AUTODOCDIR)

# Catch-all target: route all unknown targets to Sphinx using the new
# "make mode" option.  $(O) is meant as a shortcut for $(SPHINXOPTS).
%: Makefile
	@$(SPHINXBUILD) -M $@ "$(SOURCEDIR)" "$(BUILDDIR)" $(SPHINXOPTS) $(O)
</file>

<file path="docs/readme.md">
```{include} ../README.md
:relative-docs: docs/
:relative-images:
```
</file>

<file path="docs/requirements.txt">
# Requirements file for ReadTheDocs, check .readthedocs.yml.
# To build the module reference correctly, make sure every external package
# under `install_requires` in `setup.cfg` is also listed here!
# sphinx_rtd_theme
myst-parser[linkify]
sphinx>=3.2.1
</file>

<file path="src/svg_removeoverlap/__init__.py">
from importlib.metadata import PackageNotFoundError, version  # pragma: no cover

try:
    # Change here if project is renamed and does not equal the package name
    dist_name = __name__
    __version__ = version(dist_name)
except PackageNotFoundError:  # pragma: no cover
    __version__ = "unknown"
finally:
    del version, PackageNotFoundError
</file>

<file path="src/svg_removeoverlap/__main__.py">
#!/usr/bin/env python3
import logging
from pathlib import Path
from typing import Union

import fire

from .remover import RemoveOverlapsSVG


def remove_overlaps(
    input_svg: Union[str, Path],
    output_svg: Union[str, Path],
    sequential: bool = False,
    keep_white: bool = False,
    cairo: bool = True,
    picofy: bool = True,
    verbose: bool = False,
) -> None:
    """
    Removes overlapping shapes in an SVG file and saves the result to a new SVG file.

    Args:
        input_svg (Union[str, Path]): Input SVG file path.
        output_svg (Union[str, Path]): Output SVG file path.
        sequential (bool, optional): If True, process shapes sequentially instead of all at once. Defaults to False.
        keep_white (bool, optional): If True, keep white shapes. Defaults to False.
        cairo (bool, optional): If True, use cairo to convert input SVG. Defaults to True.
        picofy (bool, optional): If True, use picosvg to simplify input SVG. Defaults to True.
        verbose (bool, optional): If True, display detailed logging information. Defaults to False.
    """
    if verbose:
        logging.basicConfig(
            level=logging.INFO, format="%(levelname)s: %(message)s"
        )
    else:
        logging.basicConfig(
            level=logging.WARNING, format="%(levelname)s: %(message)s"
        )

    # The verbose flag in RemoveOverlapsSVG is now primarily for tqdm visibility
    remover = RemoveOverlapsSVG(
        cairo=cairo, picofy=picofy, keep_white=keep_white, verbose=verbose
    )
    remover.load_svg(Path(input_svg))
    remover.remove(sequential=sequential)
    remover.save_svg(Path(output_svg))

def cli():
    fire.core.Display = lambda lines, out: print(*lines, file=out)
    fire.Fire(remove_overlaps)

if __name__ == "__main__":
    cli()
</file>

<file path="src/svg_removeoverlap/remover.py">
#!/usr/bin/env python3
import logging
from pathlib import Path
import sys
from typing import List, Union, Optional

import picosvg.svg
import picosvg.svg_pathops
from lxml import etree
from tqdm import tqdm
import tinycss2

logger = logging.getLogger(__name__)

from lxml import etree

class SVGProcessingError(Exception):
    """Custom exception for errors during SVG processing."""
    pass

def get_css_fill(style: str) -> str:
    """Extract the fill value from a CSS style string.

    Args:
        style (str): The CSS style string.

    Returns:
        str: The fill value found in the CSS style string.
    """
    try:
        return (
            next(
                (
                    token.value[0].serialize()
                    for token in tinycss2.parse_declaration_list(style)
                    if hasattr(token, "name") and token.name == "fill"
                ),
                "",
            )
            .replace(" ", "")
            .lower()
        )
    except ValueError:
        return ""

class RemoveOverlapsSVG:
    def __init__(
        self,
        cairo: bool = True,
        picofy: bool = False,
        keep_white: bool = False,
        skip_svg_fills: Optional[List[str]] = None,
        verbose: bool = False,
    ) -> None:
        """Initialize RemoveOverlapsSVG class.

        Args:
            cairo (bool, optional): Use CairoSVG for SVG conversion. Defaults to True.
            picofy (bool, optional): Convert SVG to picosvg. Defaults to False.
            keep_white (bool, optional): Keep white fill shapes. Defaults to False.
            skip_svg_fills (Optional[List[str]], optional): List of fill values to skip. Defaults to a list of common white and transparent fill values.
            verbose (bool, optional): Enable verbose logging. Defaults to False.
        """
        self.skip_svg_fills: List[str] = skip_svg_fills if skip_svg_fills is not None else [
            "white",
            "rgb(255,255,255)",
            "rgb(100%,100%,100%)",
            "rgba(255,255,255,1)",
            "hsl(0,0%,100%)",
            "hsla(0,0%,100%,1)",
            "transparent",
            "#ffffff",
            "none",
        ]
        self.cairo: bool = cairo
        self.picofy: bool = picofy
        self.keep_white: bool = keep_white
        self.verbose: bool = verbose # Used for tqdm and potentially other conditional logic
        self.svg_content: Optional[str] = None
        self.pico: Optional[picosvg.svg.SVG] = None

    def _protect_clipPaths(self, svg_bytes: bytes) -> str:
        """Protect clipPaths by setting their fill to transparent.

        Args:
            svg_bytes (bytes): SVG content as bytes.

        Returns:
            str: Modified SVG content as string.
        """
        try:
            root = etree.fromstring(svg_bytes)
        except (etree.XMLSyntaxError, etree.LxmlError) as err:
            logger.error(f"XML parsing error in _protect_clipPaths: {err}")
            raise SVGProcessingError(f"Invalid XML structure in SVG for clipPath processing: {err}") from err
        clip_paths = root.findall(".//{http://www.w3.org/2000/svg}clipPath")
        for clip_path in clip_paths:
            paths = clip_path.findall("{http://www.w3.org/2000/svg}path")
            for path in paths:
                path.set("fill", "transparent")
        return etree.tostring(root, encoding="UTF-8", xml_declaration=True).decode(
            "utf-8"
        )

    def _prep_svg_cairo(self) -> None:
        """Prepare the SVG content for CairoSVG conversion."""
        if self.svg_content is None:
            # This case should ideally not be reached if load_svg was called.
            raise SVGProcessingError("SVG content not loaded before Cairo preprocessing.")
        from cairosvg.surface import SVGSurface

        try:
            converted_svg_bytes = SVGSurface.convert(bytestring=bytes(self.svg_content, encoding="utf-8"))
            self.svg_content = self._protect_clipPaths(converted_svg_bytes)
            logger.info("CairoSVG conversion successful.")
        except ValueError as ve:
            logger.error(f"CairoSVG ValueError during conversion: {ve}")
            raise SVGProcessingError(f"CairoSVG failed to convert SVG due to invalid input or structure: {ve}") from ve
        except Exception as e:
            logger.error(f"Unexpected error during CairoSVG conversion: {e}")
            # Consider logging self.svg_content or part of it if small, for debugging, but be careful with large files.
            # For now, just raise the more generic error.
            raise SVGProcessingError(f"An unexpected error occurred with CairoSVG processing: {e}") from e

    def save_svg(self, output_path: Union[str, Path]) -> None:
        """Save the SVG content to a file.

        Args:
            output_path (Union[str, Path]): The path of the output file.
        """
        output_path = Path(output_path)
        output_path.parent.mkdir(parents=True, exist_ok=True)
        logger.info(f"Saving {output_path}...")
        with open(output_path, "w") as output_file:
            output_file.write(self.svg_content)

    def load_svg(self, input_path: Union[str, Path]) -> None:
        """Load an SVG file and read its content.

        Args:
            input_path (Union[str, Path]): The path of the input file.
        """
        if not input_path:
            raise ValueError("The input path cannot be empty.")

        input_path = Path(input_path)

        if not input_path.exists():
            raise FileNotFoundError(f"The input path {input_path} does not exist.")

        if not input_path.is_file():
            raise NotADirectoryError(f"The input path {input_path} is not a file.")

        logger.info(f"Reading {input_path}...")
        with open(input_path, "r") as svg_file:
            self.svg_content = svg_file.read()
        if self.cairo:
            self._prep_svg_cairo()

    def _parse_svg(self):
        """Parse the SVG content and create an SVG object using picosvg."""
        logger.info("Parsing SVG...")
        if self.svg_content is None:
            raise SVGProcessingError("SVG content not loaded before parsing.")
        try:
            self.pico = picosvg.svg.SVG.fromstring(self.svg_content)
        except picosvg.svg.SVGParseError as spe:
            logger.error(f"Picosvg failed to parse SVG: {spe}")
            raise SVGProcessingError(f"Picosvg failed to parse SVG content: {spe}") from spe
        except ValueError as ve: # picosvg might also raise ValueError for certain issues
            logger.error(f"Picosvg encountered a ValueError during parsing: {ve}")
            raise SVGProcessingError(f"Picosvg encountered a ValueError parsing SVG content: {ve}") from ve
        except Exception as e: # Catch any other unexpected errors from picosvg
            logger.error(f"Unexpected error during picosvg parsing: {e}")
            raise SVGProcessingError(f"An unexpected error occurred during picosvg parsing: {e}") from e

    def _picofy_svg(self):
        """Convert the SVG object to a picosvg representation if the 'picofy' option is enabled."""
        if self.picofy:
            if self.pico is None:
                raise SVGProcessingError("PicoSVG object not available for picofying.")
            logger.info("Picofying SVG...")
            try:
                self.pico = self.pico.topicosvg() # This re-assigns self.pico
                if self.pico is None: # Should not happen if topicosvg() is well-behaved
                    raise SVGProcessingError("PicoSVG object became None after topicosvg().")
                self.svg_content = self.pico.tostring(pretty_print=False)
            except Exception as e:
                logger.warning(f"Failed to picofy SVG: {e}")
                raise SVGProcessingError(f"Failed during picosvg simplification (topicosvg): {e}") from e

    def _prep_pico(self):
        """Prepare the picosvg object by parsing the SVG content and optionally converting it to a picosvg representation."""
        # Exceptions from _parse_svg and _picofy_svg are now specific and will propagate.
        self._parse_svg()
        self._picofy_svg()

    def _filter_pico_shapes(self):
        """Filter the shapes in the picosvg object based on their fill values.

        Returns:
            List[picosvg.svg.Shapes]: A list of filtered shapes.
        """
        if self.pico is None:
            raise SVGProcessingError("PicoSVG object not available for filtering shapes.")

        shapes = []
        for shape in tqdm(
            self.pico.shapes(),
            desc="Converting paths",
            disable=not self.verbose or not sys.stdout.isatty(),
        ):
            fill = get_css_fill(shape.style) or shape.fill.replace(" ", "").lower()
            if (self.keep_white) or (fill not in self.skip_svg_fills):
                shapes.append(shape)
        return shapes


    def remove_overlaps_pico(self, sequential: bool = False) -> None:
        """Remove overlaps in the SVG using picosvg.

        Args:
            sequential (bool, optional): Remove overlaps sequentially. Defaults to False.
        """
        self._prep_pico()
        shapes = self._filter_pico_shapes()
        clip_rule = "nonzero"
        clip_rules = [clip_rule] * len(shapes)

        if sequential:
            new_shape = shapes[0]
            for shape in tqdm(
                shapes[1:],
                desc="Removing overlaps",
                disable=not self.verbose or not sys.stdout.isatty(),
            ):
                new_shape = picosvg.svg_pathops.union(
                    [new_shape, shape], [clip_rule, clip_rule]
                )
        else:
            logger.info("Removing overlaps...")
            try:
                new_shape = picosvg.svg_pathops.union(shapes, clip_rules)
            except Exception as e:
                logger.error(f"Error during picosvg.svg_pathops.union: {e}")
                raise SVGProcessingError(f"Failed to compute union of shapes: {e}") from e
        try:
            union_d = picosvg.svg.SVGPath.from_commands(new_shape).d
        except Exception as e:
            logger.error(f"Error converting new shape to path 'd' attribute: {e}")
            raise SVGProcessingError(f"Failed to construct path data from unioned shape: {e}") from e

        if self.pico is None or self.pico.svg_root is None:
            raise SVGProcessingError("PicoSVG object or its root not available for rebuilding SVG after overlap removal.")

        new_root = etree.Element("svg")
        for a, v in self.pico.svg_root.attrib.items(): # type: ignore # MyPy might not know svg_root type if pico is from mock
            new_root.set(a, v)
        new_root.set("xmlns", "http://www.w3.org/2000/svg")

        new_svg_obj = picosvg.svg.SVG(new_root)
        if self.pico.view_box is not None:
            new_svg_obj.view_box = self.pico.view_box

        path_el = etree.SubElement(new_root, "path")
        path_el.set("d", union_d)

        self.pico = new_svg_obj # self.pico is now the new SVG structure
        if self.pico is None: # Should not happen
             raise SVGProcessingError("SVG object became None unexpectedly after rebuilding.")
        self.svg_content = self.pico.tostring(pretty_print=True)

    def remove(self, sequential: bool = False) -> None:
        """Remove overlaps in the SVG.

        Args:
            sequential (bool, optional): Remove overlaps sequentially. Defaults to False.
        """
        self.remove_overlaps_pico(sequential=sequential)
</file>

<file path="tests/fixtures/no_overlap.svg">
<svg width="100" height="100" xmlns="http://www.w3.org/2000/svg">
    <rect x="10" y="10" width="30" height="30" fill="green"/>
    <rect x="50" y="50" width="30" height="30" fill="yellow"/>
</svg>
</file>

<file path="tests/fixtures/simple_overlap.svg">
<svg width="100" height="100" xmlns="http://www.w3.org/2000/svg">
    <rect x="10" y="10" width="50" height="50" fill="red"/>
    <rect x="40" y="40" width="50" height="50" fill="blue"/>
</svg>
</file>

<file path="tests/fixtures/with_white.svg">
<svg width="100" height="100" xmlns="http://www.w3.org/2000/svg">
    <rect x="10" y="10" width="50" height="50" fill="black"/>
    <rect x="40" y="40" width="50" height="50" fill="white"/>
</svg>
</file>

<file path="tests/conftest.py">
"""
    Dummy conftest.py for svg_removeoverlap.

    If you don't know what this is for, just leave it empty.
    Read more about conftest.py under:
    - https://docs.pytest.org/en/stable/fixture.html
    - https://docs.pytest.org/en/stable/writing_plugins.html
"""

# import pytest
</file>

<file path="tests/test_cli.py">
import pytest
from pathlib import Path
import subprocess
from lxml import etree # For parsing output XML

FIXTURE_DIR = Path(__file__).parent / "fixtures"
MAIN_SCRIPT = ["svg_removeoverlap"] # Assuming it's installed and in PATH or using entry point

def run_cli(args):
    """Helper function to run the CLI command and return result."""
    return subprocess.run(MAIN_SCRIPT + args, capture_output=True, text=True)

def test_cli_help():
    result = run_cli(["--help"])
    assert result.returncode == 0
    assert "svg_removeoverlap" in result.stdout
    assert "INPUT_SVG" in result.stdout
    assert "OUTPUT_SVG" in result.stdout

def test_cli_basic_processing(tmp_path):
    input_svg = FIXTURE_DIR / "simple_overlap.svg"
    output_svg = tmp_path / "cli_output.svg"

    result = run_cli([str(input_svg), str(output_svg)])

    assert result.returncode == 0, f"CLI Error: {result.stderr}"
    assert output_svg.exists()
    assert output_svg.stat().st_size > 0

    try:
        output_tree = etree.parse(str(output_svg))
        output_root = output_tree.getroot()
        assert output_root.tag == "{http://www.w3.org/2000/svg}svg"
    except etree.XMLSyntaxError as e:
        pytest.fail(f"CLI Output SVG is not well-formed XML: {e}\nContent:\n{output_svg.read_text()}")

def test_cli_keep_white(tmp_path):
    input_svg = FIXTURE_DIR / "with_white.svg"
    output_svg = tmp_path / "cli_output_white.svg"

    # Test without keep_white (default: white removed)
    result_no_keep = run_cli([str(input_svg), str(output_svg)])
    assert result_no_keep.returncode == 0, f"CLI Error (no keep_white): {result_no_keep.stderr}"
    assert output_svg.exists()
    content_no_keep = output_svg.read_text().lower()
    assert 'fill="white"' not in content_no_keep and 'fill="#ffffff"' not in content_no_keep

    # Test with keep_white
    output_svg_kept = tmp_path / "cli_output_white_kept.svg"
    result_keep = run_cli([str(input_svg), str(output_svg_kept), "--keep_white"]) # or -k
    assert result_keep.returncode == 0, f"CLI Error (keep_white): {result_keep.stderr}"
    assert output_svg_kept.exists()
    content_kept = output_svg_kept.read_text().lower()
    assert 'fill="white"' in content_kept or 'fill="#ffffff"' in content_kept

def test_cli_verbose_option(tmp_path):
    input_svg = FIXTURE_DIR / "no_overlap.svg"
    output_svg = tmp_path / "cli_output_verbose.svg"

    result = run_cli([str(input_svg), str(output_svg), "--verbose"]) # or -v
    assert result.returncode == 0, f"CLI Error: {result.stderr}"
    assert output_svg.exists()
    # Verbose should produce INFO level logs, which go to stdout for Fire by default
    # if logging is configured as in __main__.py to print to console.
    # The default fire.core.Display prints to stdout.
    # Our __main__ configures logging to print to console.
    assert "INFO: Reading" in result.stdout or "INFO: Saving" in result.stdout # Check for logger output

def test_cli_input_file_not_found(tmp_path):
    non_existent_input = "does_not_exist.svg"
    output_svg = tmp_path / "output.svg"
    result = run_cli([non_existent_input, str(output_svg)])
    assert result.returncode != 0 # Expect an error
    # Fire usually prints the traceback to stderr
    assert "FileNotFoundError" in result.stderr

# TODO: Add CLI test for --sequential option
# TODO: Add CLI test for --cairo and --picofy if reliable way to test their effects via CLI
#       (e.g. if they change output structure significantly or handle specific SVGs differently)
# TODO: Add CLI tests for more complex error conditions if possible from CLI
#       (e.g., providing a malformed SVG that causes SVGProcessingError)
#       This would check if the error is reported reasonably on stderr.
</file>

<file path="tests/test_integration.py">
import pytest
from pathlib import Path
from lxml import etree # For parsing output XML

from svg_removeoverlap.remover import RemoveOverlapsSVG

FIXTURE_DIR = Path(__file__).parent / "fixtures"

@pytest.mark.parametrize(
    "input_svg_name, keep_white_setting, cairo_setting, picofy_setting",
    [
        ("simple_overlap.svg", False, False, False),
        ("no_overlap.svg", False, False, False),
        ("with_white.svg", False, False, False), # white should be removed
        ("with_white.svg", True, False, False),  # white should be kept
        # TODO: Could add cases for cairo=True if cairo is reliably available in test env
        # ("simple_overlap.svg", False, True, False),
    ]
)
def test_svg_processing_integration(tmp_path, input_svg_name, keep_white_setting, cairo_setting, picofy_setting):
    input_svg_path = FIXTURE_DIR / input_svg_name
    output_svg_path = tmp_path / f"output_{input_svg_name}"

    remover = RemoveOverlapsSVG(
        cairo=cairo_setting,
        picofy=picofy_setting,
        keep_white=keep_white_setting,
        verbose=True # Enable verbose for more log output during tests if needed
    )

    remover.load_svg(input_svg_path)
    # The remove() method calls remove_overlaps_pico() internally
    remover.remove(sequential=False) # Test with non-sequential for now
    remover.save_svg(output_svg_path)

    assert output_svg_path.exists()
    assert output_svg_path.stat().st_size > 0 # Check file is not empty

    # Try to parse the output SVG to ensure it's valid XML and has an <svg> root
    try:
        output_tree = etree.parse(str(output_svg_path))
        output_root = output_tree.getroot()
        assert output_root.tag == "{http://www.w3.org/2000/svg}svg", "Output is not a valid SVG file"
    except etree.XMLSyntaxError as e:
        pytest.fail(f"Output SVG file is not well-formed XML: {e}\nContent:\n{output_svg_path.read_text()}")

    # Specific assertions based on input and settings
    # These are examples and might need refinement
    output_content = output_svg_path.read_text().lower()
    if input_svg_name == "simple_overlap.svg":
        # After union, there should ideally be a single path if all shapes are combined.
        # This depends heavily on picosvg's output.
        # A simpler check might be that "red" and "blue" fills are gone if not preserved by some logic.
        # For now, we mainly check it produces a valid SVG.
        pass
    elif input_svg_name == "with_white.svg":
        if keep_white_setting:
            assert 'fill="white"' in output_content or 'fill="#ffffff"' in output_content # Check white is present
        else:
            assert 'fill="white"' not in output_content and 'fill="#ffffff"' not in output_content # Check white is absent

    # More specific assertions could be:
    # - Counting number of <path> elements (e.g., expect 1 after union of overlapping shapes)
    # - Checking for the absence/presence of certain fill colors in the final output.
    # - Verifying viewbox consistency.
    # These would require more knowledge of the expected output from picosvg.

# TODO: Add integration test for sequential=True mode.
# TODO: Add integration tests for error conditions (e.g., malformed input SVG that passes initial load but fails in picosvg).
#       This might require creating specific malformed SVG fixture files.
#       Example: an SVG that is XML-valid but has problematic path data for picosvg.
# remover.remove(sequential=True)
# assert ...
</file>

<file path="tests/test_remover.py">
from unittest import mock
import pytest

from svg_removeoverlap.remover import get_css_fill, SVGProcessingError, RemoveOverlapsSVG
from pathlib import Path


# Tests for get_css_fill
@pytest.mark.parametrize(
    "style_str, expected_fill",
    [
        ("fill:#ff0000;", "#ff0000"),
        ("fill: red; stroke: blue;", "red"),
        ("font-size: 12px; fill:rgb(0,255,0);", "rgb(0,255,0)"),
        ("fill: hsl(120, 100%, 50%);", "hsl(120,100%,50%)"), # Test case with space in hsl
        ("fill:none;", "none"),
        ("stroke: black;", ""), # No fill
        ("", ""), # Empty string
        ("fill: ;", ""), # Fill with no value
        ("fill: red; fill: blue;", "red"), # First one wins as per current implementation logic
        ("fill:#FF0000;", "#ff0000"), # Case insensitivity for hex
        ("fill: RGB(0,255,0);", "rgb(0,255,0)"), # Case insensitivity for rgb
        ("fill: HSL(120,100%,50%);", "hsl(120,100%,50%)"), # Case insensitivity for hsl
        # Malformed but tinycss2 might recover or ignore
        ("fill: red stroke: blue", "red"), # Missing semicolon
        ("fill : yellow", "yellow"), # Space around colon
    ],
)
def test_get_css_fill(style_str, expected_fill):
    assert get_css_fill(style_str) == expected_fill

# Placeholder for tests for RemoveOverlapsSVG class
class TestRemoveOverlapsSVG:
    def test_dummy(self): # Dummy test to make sure the class can be instantiated
        remover = RemoveOverlapsSVG(cairo=False) # Disable cairo for basic instantiation test
        assert remover is not None

    @pytest.fixture
    def remover_no_cairo(self):
        return RemoveOverlapsSVG(cairo=False, picofy=False)

    def test_load_svg_empty_path(self, remover_no_cairo):
        with pytest.raises(ValueError, match="The input path cannot be empty."):
            remover_no_cairo.load_svg(None)
        with pytest.raises(ValueError, match="The input path cannot be empty."):
            remover_no_cairo.load_svg("")

    def test_load_svg_file_not_found(self, remover_no_cairo):
        with pytest.raises(FileNotFoundError, match="The input path non_existent_file.svg does not exist."):
            remover_no_cairo.load_svg(Path("non_existent_file.svg"))

    @mock.patch("pathlib.Path.is_file", return_value=False)
    @mock.patch("pathlib.Path.exists", return_value=True)
    def test_load_svg_path_is_not_a_file(self, mock_exists, mock_is_file, remover_no_cairo):
        with pytest.raises(NotADirectoryError, match="The input path path_is_a_dir is not a file."): # Corrected error type
            remover_no_cairo.load_svg(Path("path_is_a_dir"))

    @mock.patch("builtins.open", new_callable=mock.mock_open, read_data="<svg></svg>")
    @mock.patch("pathlib.Path.is_file", return_value=True)
    @mock.patch("pathlib.Path.exists", return_value=True)
    def test_load_svg_successful(self, mock_exists, mock_is_file, mock_file_open, remover_no_cairo):
        remover_no_cairo.load_svg(Path("dummy.svg"))
        assert remover_no_cairo.svg_content == "<svg></svg>"
        mock_file_open.assert_called_once_with(Path("dummy.svg"), "r")

    # Basic test for _protect_clipPaths - more detailed tests would require actual SVG content
    def test_protect_clip_paths_simple(self, remover_no_cairo):
        svg_bytes = b'<svg><clipPath id="cp1"><path d="M0,0 L10,0 L10,10 L0,10Z" fill="red"/></clipPath></svg>'
        protected_svg_str = remover_no_cairo._protect_clipPaths(svg_bytes)
        assert 'fill="transparent"' in protected_svg_str
        assert 'fill="red"' not in protected_svg_str # Ensure original fill is replaced

    def test_protect_clip_paths_malformed_xml(self, remover_no_cairo):
        svg_bytes = b'<svg><clipPath id="cp1"><path d="M0,0 L10,0 L10,10 L0,10Z" fill="red"</clipPath></svg>' # Missing quote in fill
        with pytest.raises(SVGProcessingError, match="Invalid XML structure in SVG for clipPath processing"):
            remover_no_cairo._protect_clipPaths(svg_bytes)

    # Placeholder for _prep_svg_cairo tests (requires mocking CairoSVG)
    @mock.patch("svg_removeoverlap.remover.SVGSurface")
    def test_prep_svg_cairo_called_if_enabled(self, mock_svg_surface_class, tmp_path):
        # Mock SVGSurface.convert to avoid actual CairoSVG dependency and complex return
        mock_svg_surface_class.convert.return_value = b"<svg_cairo_output></svg_cairo_output>"

        remover_with_cairo = RemoveOverlapsSVG(cairo=True)
        # Need to set svg_content before _prep_svg_cairo is called internally by load_svg
        remover_with_cairo.svg_content = "<svg_initial></svg_initial>"

        # Create a dummy file to load
        dummy_svg_path = tmp_path / "dummy_cairo.svg"
        dummy_svg_path.write_text("<svg_initial></svg_initial>")

        remover_with_cairo.load_svg(dummy_svg_path) # This will call _prep_svg_cairo

        mock_svg_surface_class.convert.assert_called_once()
        # Check that svg_content was modified by the mocked _protect_clipPaths (called by _prep_svg_cairo)
        # This is an indirect check that _prep_svg_cairo's flow was entered
        assert remover_with_cairo.svg_content != "<svg_initial></svg_initial>"
        assert "<svg_cairo_output>" in remover_with_cairo.svg_content # More direct check after _protect_clipPaths

    @mock.patch("svg_removeoverlap.remover.SVGSurface")
    def test_prep_svg_cairo_handles_conversion_error(self, mock_svg_surface_class):
        mock_svg_surface_class.convert.side_effect = ValueError("Cairo conversion failed")

        remover = RemoveOverlapsSVG(cairo=True)
        remover.svg_content = "<svg></svg>" # Set content to trigger conversion
        with pytest.raises(SVGProcessingError, match="CairoSVG failed to convert SVG"):
            remover._prep_svg_cairo() # Call directly for this test

    # More tests will be added here for:
    # - _parse_svg, _picofy_svg, _prep_pico (mocking picosvg)
    @mock.patch("svg_removeoverlap.remover.picosvg.svg.SVG")
    def test_parse_svg_successful(self, mock_picosvg_svg_class, remover_no_cairo):
        mock_svg_instance = mock.MagicMock()
        mock_picosvg_svg_class.fromstring.return_value = mock_svg_instance
        remover_no_cairo.svg_content = "<svg></svg>"

        remover_no_cairo._parse_svg()

        mock_picosvg_svg_class.fromstring.assert_called_once_with("<svg></svg>")
        assert remover_no_cairo.pico == mock_svg_instance

    @mock.patch("svg_removeoverlap.remover.picosvg.svg.SVG")
    def test_parse_svg_handles_parse_error(self, mock_picosvg_svg_class, remover_no_cairo):
        # Need to import picosvg.svg directly here to reference SVGParseError for the side_effect
        from picosvg.svg import SVGParseError
        mock_picosvg_svg_class.fromstring.side_effect = SVGParseError("Picosvg parsing failed")
        remover_no_cairo.svg_content = "<svg_malformed></svg_malformed>"

        with pytest.raises(SVGProcessingError, match="Picosvg failed to parse SVG content"):
            remover_no_cairo._parse_svg()

    @mock.patch("svg_removeoverlap.remover.picosvg.svg.SVG") # Mock the class used by _parse_svg
    def test_picofy_svg_when_enabled(self, mock_picosvg_svg_class_for_parse, remover_no_cairo):
        # Setup for _parse_svg to run without error
        mock_parsed_svg_instance = mock.MagicMock()
        mock_picofied_svg_instance = mock.MagicMock()
        mock_parsed_svg_instance.topicosvg.return_value = mock_picofied_svg_instance
        mock_picofied_svg_instance.tostring.return_value = "<picofied_svg/>"
        mock_picosvg_svg_class_for_parse.fromstring.return_value = mock_parsed_svg_instance

        remover_no_cairo.svg_content = "<svg_content_for_picofy>"
        remover_no_cairo.picofy = True # Enable picofy

        remover_no_cairo._prep_pico() # This calls _parse_svg then _picofy_svg

        mock_parsed_svg_instance.topicosvg.assert_called_once()
        mock_picofied_svg_instance.tostring.assert_called_once_with(pretty_print=False)
        assert remover_no_cairo.pico == mock_picofied_svg_instance
        assert remover_no_cairo.svg_content == "<picofied_svg/>"

    @mock.patch("svg_removeoverlap.remover.picosvg.svg.SVG")
    def test_picofy_svg_handles_error(self, mock_picosvg_svg_class_for_parse, remover_no_cairo):
        mock_parsed_svg_instance = mock.MagicMock()
        mock_parsed_svg_instance.topicosvg.side_effect = Exception("Picofy failed")
        mock_picosvg_svg_class_for_parse.fromstring.return_value = mock_parsed_svg_instance

        remover_no_cairo.svg_content = "<svg_content_for_picofy>"
        remover_no_cairo.picofy = True

        with pytest.raises(SVGProcessingError, match="Failed during picosvg simplification"):
            remover_no_cairo._prep_pico()

    def test_prep_pico_calls_parse_and_picofy(self, remover_no_cairo):
        remover_no_cairo.svg_content = "<svg></svg>"
        remover_no_cairo.picofy = True # Ensure _picofy_svg is also called

        with mock.patch.object(remover_no_cairo, '_parse_svg') as mock_parse, \
             mock.patch.object(remover_no_cairo, '_picofy_svg') as mock_picofy:

            remover_no_cairo._prep_pico()

            mock_parse.assert_called_once()
            mock_picofy.assert_called_once()

    def test_filter_pico_shapes(self, remover_no_cairo):
        # Mock shapes
        shape1 = mock.MagicMock(style="fill:red;", fill="") # Red
        shape2 = mock.MagicMock(style="fill:white;", fill="") # White
        shape3 = mock.MagicMock(style="", fill="blue") # Blue
        shape4 = mock.MagicMock(style="fill:#FFFFFF;", fill="") # White (hex)
        shape5 = mock.MagicMock(style="fill:transparent;", fill="") # Transparent
        shape6 = mock.MagicMock(style="fill:none", fill="") # None
        shape7 = mock.MagicMock(style="fill:rgb(0,0,0)", fill="") # Black

        all_shapes = [shape1, shape2, shape3, shape4, shape5, shape6, shape7]

        # Mock remover.pico.shapes()
        remover_no_cairo.pico = mock.MagicMock()
        remover_no_cairo.pico.shapes.return_value = all_shapes

        # Test 1: keep_white = False (default)
        remover_no_cairo.keep_white = False
        # Default skip_svg_fills includes "white", "#ffffff", "transparent", "none", etc.
        filtered_shapes = remover_no_cairo._filter_pico_shapes()
        assert shape1 in filtered_shapes # red
        assert shape2 not in filtered_shapes # white
        assert shape3 in filtered_shapes # blue
        assert shape4 not in filtered_shapes # #FFFFFF
        assert shape5 not in filtered_shapes # transparent
        assert shape6 not in filtered_shapes # none
        assert shape7 in filtered_shapes # black
        assert len(filtered_shapes) == 3

        # Test 2: keep_white = True
        remover_no_cairo.keep_white = True
        filtered_shapes_keep_white = remover_no_cairo._filter_pico_shapes()
        # Should keep white, but still skip "transparent" and "none" based on default skip_svg_fills
        assert shape1 in filtered_shapes_keep_white
        assert shape2 in filtered_shapes_keep_white # white is kept
        assert shape3 in filtered_shapes_keep_white
        assert shape4 in filtered_shapes_keep_white # #FFFFFF is kept
        assert shape5 not in filtered_shapes_keep_white # transparent is still skipped
        assert shape6 not in filtered_shapes_keep_white # none is still skipped
        assert shape7 in filtered_shapes_keep_white
        assert len(filtered_shapes_keep_white) == 5

        # Test 3: Custom skip_svg_fills
        remover_no_cairo.keep_white = False # Reset
        remover_no_cairo.skip_svg_fills = ["red", "blue"] # Custom skip
        filtered_shapes_custom_skip = remover_no_cairo._filter_pico_shapes()
        assert shape1 not in filtered_shapes_custom_skip # red is skipped
        assert shape2 in filtered_shapes_custom_skip # white is kept (not in custom skip)
        assert shape3 not in filtered_shapes_custom_skip # blue is skipped
        assert shape4 in filtered_shapes_custom_skip # #FFFFFF is kept
        assert shape5 in filtered_shapes_custom_skip # transparent is kept
        assert shape6 in filtered_shapes_custom_skip # none is kept
        assert shape7 in filtered_shapes_custom_skip # black is kept
        assert len(filtered_shapes_custom_skip) == 5

    @mock.patch("svg_removeoverlap.remover.picosvg.svg_pathops.union")
    @mock.patch("svg_removeoverlap.remover.picosvg.svg.SVGPath")
    @mock.patch("svg_removeoverlap.remover.etree") # To mock etree.Element and SubElement
    def test_remove_overlaps_pico_non_sequential(self, mock_etree, mock_svgpath_class, mock_union, remover_no_cairo):
        # Setup remover instance
        remover_no_cairo.svg_content = "<svg viewBox='0 0 100 100'><path d='dummy'/></svg>" # Needs some content to parse

        # Mock _prep_pico to set up a mock pico object
        mock_pico_instance = mock.MagicMock()
        mock_pico_instance.svg_root.attrib = {'viewBox': '0 0 100 100', 'xmlns': 'http://www.w3.org/2000/svg'}
        mock_pico_instance.view_box = (0, 0, 100, 100)

        # Mock _filter_pico_shapes to return some mock shapes
        shape1 = mock.MagicMock(name="shape1")
        shape2 = mock.MagicMock(name="shape2")
        mock_filtered_shapes = [shape1, shape2]

        with mock.patch.object(remover_no_cairo, '_prep_pico', autospec=True) as mock_prep_pico_method, \
             mock.patch.object(remover_no_cairo, '_filter_pico_shapes', return_value=mock_filtered_shapes) as mock_filter_shapes_method:
            # Ensure self.pico is set by the mocked _prep_pico
            def side_effect_prep_pico():
                remover_no_cairo.pico = mock_pico_instance
            mock_prep_pico_method.side_effect = side_effect_prep_pico

            # Mock return value of picosvg.svg_pathops.union
            mock_unioned_shape_commands = [('M', (0,0))] # Dummy commands
            mock_union.return_value = mock_unioned_shape_commands

            # Mock SVGPath.from_commands().d
            mock_svgpath_instance = mock.MagicMock()
            mock_svgpath_instance.d = "M0,0 Z" # Dummy d string
            mock_svgpath_class.from_commands.return_value = mock_svgpath_instance

            # Mock etree Elements
            mock_new_root_element = mock.MagicMock(name="new_root_svg_element")
            mock_etree.Element.return_value = mock_new_root_element
            mock_path_el = mock.MagicMock(name="new_path_element")
            mock_etree.SubElement.return_value = mock_path_el

            # Mock the SVG class constructor used for new_svg
            with mock.patch("svg_removeoverlap.remover.picosvg.svg.SVG") as mock_final_svg_constructor:
                mock_final_svg_instance = mock.MagicMock(name="final_svg_object")
                mock_final_svg_instance.tostring.return_value = "<svg_final_output/>"
                mock_final_svg_constructor.return_value = mock_final_svg_instance

                # Call the method under test
                remover_no_cairo.remove_overlaps_pico(sequential=False)

                mock_prep_pico_method.assert_called_once()
                mock_filter_shapes_method.assert_called_once()

                # Check union call
                mock_union.assert_called_once_with(mock_filtered_shapes, ["nonzero", "nonzero"])
                mock_svgpath_class.from_commands.assert_called_once_with(mock_unioned_shape_commands)

                # Check etree usage
                mock_etree.Element.assert_called_once_with("svg")
                assert mock_new_root_element.set.call_count == 2 # viewBox, xmlns
                mock_new_root_element.set.assert_any_call('viewBox', '0 0 100 100')
                mock_new_root_element.set.assert_any_call('xmlns', 'http://www.w3.org/2000/svg')

                mock_etree.SubElement.assert_called_once_with(mock_new_root_element, "path")
                mock_path_el.set.assert_called_once_with("d", "M0,0 Z")

                # Check final SVG object creation and output
                mock_final_svg_constructor.assert_called_once_with(mock_new_root_element)
                assert mock_final_svg_instance.view_box == (0,0,100,100)
                assert remover_no_cairo.svg_content == "<svg_final_output/>"
                assert remover_no_cairo.pico == mock_final_svg_instance

    # TODO: Add test for sequential=True mode in remove_overlaps_pico
    # This will involve similar mocking but checking that union is called multiple times in a loop.

    # - Different options (sequential, keep_white) are partially covered by _filter_pico_shapes
    #   and can be further tested via integration tests.
    pass
</file>

<file path=".coveragerc">
# .coveragerc to control coverage.py
[run]
branch = True
source = svg_removeoverlap
# omit = bad_file.py

[paths]
source =
    src/
    */site-packages/

[report]
# Regexes for lines to exclude from consideration
exclude_lines =
    # Have to re-enable the standard pragma
    pragma: no cover

    # Don't complain about missing debug-only code:
    def __repr__
    if self\.debug

    # Don't complain if tests don't hit defensive assertion code:
    raise AssertionError
    raise NotImplementedError

    # Don't complain if non-runnable code isn't run:
    if 0:
    if __name__ == .__main__.:
</file>

<file path=".gitignore">
.DS_Store

# Temporary and binary files
*~
*.py[cod]
*.so
*.cfg
!.isort.cfg
!setup.cfg
*.orig
*.log
*.pot
__pycache__/*
.cache/*
.*.swp
*/.ipynb_checkpoints/*
.DS_Store

# Project files
.ropeproject
.project
.pydevproject
.settings
.idea
.vscode
tags

# Package files
*.egg
*.eggs/
.installed.cfg
*.egg-info

# Unittest and coverage
htmlcov/*
.coverage
.coverage.*
.tox
junit*.xml
coverage.xml
.pytest_cache/

# Build and docs folder/files
build/*
dist/*
sdist/*
docs/api/*
docs/_rst/*
docs/_build/*
cover/*
MANIFEST

# Per-project virtualenvs
.venv*/
.conda*/
.python-version
</file>

<file path=".isort.cfg">
[settings]
profile = black
known_first_party = svg_removeoverlap
</file>

<file path=".pre-commit-config.yaml">
exclude: '^docs/conf.py'

repos:
- repo: https://github.com/pre-commit/pre-commit-hooks
  rev: v4.6.0
  hooks:
  - id: trailing-whitespace
  - id: check-added-large-files
  - id: check-ast
  - id: check-json
  - id: check-merge-conflict
  - id: check-xml
  - id: check-yaml
  - id: debug-statements
  - id: end-of-file-fixer
  - id: requirements-txt-fixer
  - id: mixed-line-ending
    args: ['--fix=auto']  # replace 'auto' with 'lf' to enforce Linux/Mac line endings or 'crlf' for Windows

## If you want to automatically "modernize" your Python code:
# - repo: https://github.com/asottile/pyupgrade
#   rev: v3.15.2 # Updated rev
#   hooks:
#   - id: pyupgrade
#     args: ['--py38-plus'] # Updated to py38-plus

## If you want to avoid flake8 errors due to unused vars or imports:
# - repo: https://github.com/PyCQA/autoflake
#   rev: v2.3.1 # Updated rev
#   hooks:
#   - id: autoflake
#     args: [
#       --in-place,
#       --remove-all-unused-imports,
#       --remove-unused-variables,
#     ]

- repo: https://github.com/PyCQA/isort
  rev: 5.13.2
  hooks:
  - id: isort
    args: ["--profile", "black"] # Ensure isort profile matches black

- repo: https://github.com/psf/black
  rev: 24.4.2
  hooks:
  - id: black
    language_version: python3

## If like to embrace black styles even in the docs:
# - repo: https://github.com/asottile/blacken-docs
#   rev: v1.16.0 # Updated rev
#   hooks:
#   - id: blacken-docs
#     additional_dependencies: [black==24.4.2] # Match black version

- repo: https://github.com/PyCQA/flake8
  rev: 7.0.0
  hooks:
  - id: flake8
  ## You can add flake8 plugins via `additional_dependencies`:
  #  additional_dependencies: [flake8-bugbear]

## Check for misspells in documentation files:
# - repo: https://github.com/codespell-project/codespell
#   rev: v2.2.6 # Updated rev
#   hooks:
#   - id: codespell

- repo: https://github.com/pre-commit/mirrors-mypy
  rev: v1.9.0 # Match mypy version if possible
  hooks:
  - id: mypy
    args: [--no-strict-optional] # --ignore-missing-imports is in mypy.ini
    # additional_dependencies: [lxml-stubs] # If needed
</file>

<file path=".readthedocs.yml">
# Read the Docs configuration file
# See https://docs.readthedocs.io/en/stable/config-file/v2.html for details

# Required
version: 2

# Build documentation in the docs/ directory with Sphinx
sphinx:
  configuration: docs/conf.py

# Build documentation with MkDocs
#mkdocs:
#  configuration: mkdocs.yml

# Optionally build your docs in additional formats such as PDF
formats:
  - pdf

build:
  os: ubuntu-22.04
  tools:
    python: "3.11" # Keep this aligned with a recent, tested Python version

python:
  install:
    - requirements: docs/requirements.txt
    - {path: ., method: pip}
</file>

<file path="AUTHORS.md">
# Contributors

- Adam Twardoch <adam+github@twardoch.com>
</file>

<file path="LICENSE.txt">
Apache License
                           Version 2.0, January 2004
                        http://www.apache.org/licenses/

   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION

   1. Definitions.

      "License" shall mean the terms and conditions for use, reproduction,
      and distribution as defined by Sections 1 through 9 of this document.

      "Licensor" shall mean the copyright owner or entity authorized by
      the copyright owner that is granting the License.

      "Legal Entity" shall mean the union of the acting entity and all
      other entities that control, are controlled by, or are under common
      control with that entity. For the purposes of this definition,
      "control" means (i) the power, direct or indirect, to cause the
      direction or management of such entity, whether by contract or
      otherwise, or (ii) ownership of fifty percent (50%) or more of the
      outstanding shares, or (iii) beneficial ownership of such entity.

      "You" (or "Your") shall mean an individual or Legal Entity
      exercising permissions granted by this License.

      "Source" form shall mean the preferred form for making modifications,
      including but not limited to software source code, documentation
      source, and configuration files.

      "Object" form shall mean any form resulting from mechanical
      transformation or translation of a Source form, including but
      not limited to compiled object code, generated documentation,
      and conversions to other media types.

      "Work" shall mean the work of authorship, whether in Source or
      Object form, made available under the License, as indicated by a
      copyright notice that is included in or attached to the work
      (an example is provided in the Appendix below).

      "Derivative Works" shall mean any work, whether in Source or Object
      form, that is based on (or derived from) the Work and for which the
      editorial revisions, annotations, elaborations, or other modifications
      represent, as a whole, an original work of authorship. For the purposes
      of this License, Derivative Works shall not include works that remain
      separable from, or merely link (or bind by name) to the interfaces of,
      the Work and Derivative Works thereof.

      "Contribution" shall mean any work of authorship, including
      the original version of the Work and any modifications or additions
      to that Work or Derivative Works thereof, that is intentionally
      submitted to Licensor for inclusion in the Work by the copyright owner
      or by an individual or Legal Entity authorized to submit on behalf of
      the copyright owner. For the purposes of this definition, "submitted"
      means any form of electronic, verbal, or written communication sent
      to the Licensor or its representatives, including but not limited to
      communication on electronic mailing lists, source code control systems,
      and issue tracking systems that are managed by, or on behalf of, the
      Licensor for the purpose of discussing and improving the Work, but
      excluding communication that is conspicuously marked or otherwise
      designated in writing by the copyright owner as "Not a Contribution."

      "Contributor" shall mean Licensor and any individual or Legal Entity
      on behalf of whom a Contribution has been received by Licensor and
      subsequently incorporated within the Work.

   2. Grant of Copyright License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      copyright license to reproduce, prepare Derivative Works of,
      publicly display, publicly perform, sublicense, and distribute the
      Work and such Derivative Works in Source or Object form.

   3. Grant of Patent License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      (except as stated in this section) patent license to make, have made,
      use, offer to sell, sell, import, and otherwise transfer the Work,
      where such license applies only to those patent claims licensable
      by such Contributor that are necessarily infringed by their
      Contribution(s) alone or by combination of their Contribution(s)
      with the Work to which such Contribution(s) was submitted. If You
      institute patent litigation against any entity (including a
      cross-claim or counterclaim in a lawsuit) alleging that the Work
      or a Contribution incorporated within the Work constitutes direct
      or contributory patent infringement, then any patent licenses
      granted to You under this License for that Work shall terminate
      as of the date such litigation is filed.

   4. Redistribution. You may reproduce and distribute copies of the
      Work or Derivative Works thereof in any medium, with or without
      modifications, and in Source or Object form, provided that You
      meet the following conditions:

      (a) You must give any other recipients of the Work or
          Derivative Works a copy of this License; and

      (b) You must cause any modified files to carry prominent notices
          stating that You changed the files; and

      (c) You must retain, in the Source form of any Derivative Works
          that You distribute, all copyright, patent, trademark, and
          attribution notices from the Source form of the Work,
          excluding those notices that do not pertain to any part of
          the Derivative Works; and

      (d) If the Work includes a "NOTICE" text file as part of its
          distribution, then any Derivative Works that You distribute must
          include a readable copy of the attribution notices contained
          within such NOTICE file, excluding those notices that do not
          pertain to any part of the Derivative Works, in at least one
          of the following places: within a NOTICE text file distributed
          as part of the Derivative Works; within the Source form or
          documentation, if provided along with the Derivative Works; or,
          within a display generated by the Derivative Works, if and
          wherever such third-party notices normally appear. The contents
          of the NOTICE file are for informational purposes only and
          do not modify the License. You may add Your own attribution
          notices within Derivative Works that You distribute, alongside
          or as an addendum to the NOTICE text from the Work, provided
          that such additional attribution notices cannot be construed
          as modifying the License.

      You may add Your own copyright statement to Your modifications and
      may provide additional or different license terms and conditions
      for use, reproduction, or distribution of Your modifications, or
      for any such Derivative Works as a whole, provided Your use,
      reproduction, and distribution of the Work otherwise complies with
      the conditions stated in this License.

   5. Submission of Contributions. Unless You explicitly state otherwise,
      any Contribution intentionally submitted for inclusion in the Work
      by You to the Licensor shall be under the terms and conditions of
      this License, without any additional terms or conditions.
      Notwithstanding the above, nothing herein shall supersede or modify
      the terms of any separate license agreement you may have executed
      with Licensor regarding such Contributions.

   6. Trademarks. This License does not grant permission to use the trade
      names, trademarks, service marks, or product names of the Licensor,
      except as required for reasonable and customary use in describing the
      origin of the Work and reproducing the content of the NOTICE file.

   7. Disclaimer of Warranty. Unless required by applicable law or
      agreed to in writing, Licensor provides the Work (and each
      Contributor provides its Contributions) on an "AS IS" BASIS,
      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
      implied, including, without limitation, any warranties or conditions
      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
      PARTICULAR PURPOSE. You are solely responsible for determining the
      appropriateness of using or redistributing the Work and assume any
      risks associated with Your exercise of permissions under this License.

   8. Limitation of Liability. In no event and under no legal theory,
      whether in tort (including negligence), contract, or otherwise,
      unless required by applicable law (such as deliberate and grossly
      negligent acts) or agreed to in writing, shall any Contributor be
      liable to You for damages, including any direct, indirect, special,
      incidental, or consequential damages of any character arising as a
      result of this License or out of the use or inability to use the
      Work (including but not limited to damages for loss of goodwill,
      work stoppage, computer failure or malfunction, or any and all
      other commercial damages or losses), even if such Contributor
      has been advised of the possibility of such damages.

   9. Accepting Warranty or Additional Liability. While redistributing
      the Work or Derivative Works thereof, You may choose to offer,
      and charge a fee for, acceptance of support, warranty, indemnity,
      or other liability obligations and/or rights consistent with this
      License. However, in accepting such obligations, You may act only
      on Your own behalf and on Your sole responsibility, not on behalf
      of any other Contributor, and only if You agree to indemnify,
      defend, and hold each Contributor harmless for any liability
      incurred by, or claims asserted against, such Contributor by reason
      of your accepting any such warranty or additional liability.

   END OF TERMS AND CONDITIONS

   APPENDIX: How to apply the Apache License to your work.

      To apply the Apache License to your work, attach the following
      boilerplate notice, with the fields enclosed by brackets "{}"
      replaced with your own identifying information. (Don't include
      the brackets!)  The text should be enclosed in the appropriate
      comment syntax for the file format. We also recommend that a
      file or class name and description of purpose be included on the
      same "printed page" as the copyright notice for easier
      identification within third-party archives.

   Copyright {yyyy} {name of copyright owner}

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
</file>

<file path="mypy.ini">
[mypy]
python_version = 3.8
warn_return_any = True
warn_unused_configs = True
ignore_missing_imports = True
# show_error_codes = True # Useful for debugging specific errors

# Per-module settings for libraries that might cause issues
[mypy-fire.*]
ignore_missing_imports = True

[mypy-cairosvg.*]
ignore_missing_imports = True

[mypy-picosvg.*]
ignore_missing_imports = True

[mypy-tinycss2.*]
ignore_missing_imports = True

[mypy-tqdm.*]
ignore_missing_imports = True
# lxml has stubs (lxml-stubs), so we might not need to ignore it if stubs are added.
# For now, if lxml-stubs are not explicitly added as a dependency,
# mypy might complain or treat lxml as Any.
# If using lxml-stubs, remove lxml from ignore list if added.
# [mypy-lxml.*]
# ignore_missing_imports = True
</file>

<file path="pyproject.toml">
[build-system]
# AVOID CHANGING REQUIRES: IT WILL BE UPDATED BY PYSCAFFOLD!
requires = ["setuptools>=46.1.0", "setuptools_scm[toml]>=5"]
build-backend = "setuptools.build_meta"

[tool.setuptools_scm]
# For smarter version schemes and other configuration options,
# check out https://github.com/pypa/setuptools_scm
version_scheme = "no-guess-dev"
</file>

<file path="README.md">
# svg_removeoverlap

CLI tool & Python lib to remove overlap in SVG.

This Python script is designed to remove overlapping shapes in an SVG (Scalable Vector Graphics) file using the picosvg library. It provides several options to control the removal process, such as using CairoSVG for SVG conversion, converting SVG to picosvg, keeping white fill shapes, and skipping specific fill values.

## Installation

```bash
python3 -m pip install --upgrade git+https://github.com/twardoch/svg_removeoverlap
```

You also need to install external dependencies.

### On macOS

With [Homebrew](https://brew.sh/)

```bash
brew install cairo libffi pkg-config
```

### On Windows

With [vcpkg](https://github.com/microsoft/vcpkg):

```
vcpkg install cairo:x64-windows
vcpkg install libffi:x64-windows
vcpkg install pkg-config:x64-windows
```

With [Chocolatey](https://chocolatey.org/install):

```
choco install cairo
choco install pkgconfiglite
```

### On Ubuntu

```bash
sudo apt-get install libcairo2-dev libffi-dev pkg-config
```


## Usage in CLI

```bash
svg_removeoverlap input.svg output.svg
```

```
$ svg_removeoverlap --help
INFO: Showing help with the command 'svg_removeoverlap -- --help'.

NAME
    svg_removeoverlap - Removes overlapping shapes in an SVG file and saves the result to a new SVG file.

SYNOPSIS
    svg_removeoverlap INPUT_SVG OUTPUT_SVG <flags>

DESCRIPTION
    Removes overlapping shapes in an SVG file and saves the result to a new SVG file.

POSITIONAL ARGUMENTS
    INPUT_SVG
        Type: Union
        Input SVG file path.
    OUTPUT_SVG
        Type: Union
        Output SVG file path.

FLAGS
    -s, --sequential=SEQUENTIAL
        Type: bool
        Default: False
        If True, process shapes sequentially instead of all at once. Defaults to False.
    -k, --keep_white=KEEP_WHITE
        Type: bool
        Default: False
        If True, keep white shapes. Defaults to False.
    -c, --cairo=CAIRO
        Type: bool
        Default: True
        If True, use cairo to convert input SVG. Defaults to True.
    -p, --picofy=PICOFY
        Type: bool
        Default: False
        If True, use picosvg to simplify input SVG. Defaults to False.
    -v, --verbose=VERBOSE
        Type: bool
        Default: False
        If True, display detailed logging information. Defaults to False.

NOTES
    You can also use flags syntax for POSITIONAL ARGUMENTS
```

## Usage in Python

```python
from svg_removeoverlap.remover import RemoveOverlapsSVG
remover = RemoveOverlapsSVG(cairo=True, picofy=False, keep_white=False, verbose=True)
remover.load_svg(input_path)
remover.remove(sequential=False)
remover.save_svg(output_path)
```

## License

- Copyright (c) 2023 Adam Twardoch
- Licensed under the [Apache 2.0](./LICENSE.txt) license.
</file>

<file path="setup.cfg">
# This file is used to configure your project.
# Read more about the various options under:
# https://setuptools.pypa.io/en/latest/userguide/declarative_config.html
# https://setuptools.pypa.io/en/latest/references/keywords.html

[metadata]
name = svg_removeoverlap
description = CLI tool & Python lib to remove overlap in SVG
author = Adam Twardoch
author_email = adam+github@twardoch.com
license = Apache-2.0
license_files = LICENSE.txt
long_description = file: README.md
long_description_content_type = text/markdown; charset=UTF-8; variant=GFM
url = https://github.com/twardoch/svg_removeoverlap
# Add here related links, for example:
project_urls =
    Documentation = https://github.com/twardoch/svg_removeoverlap
    Source = https://github.com/twardoch/svg_removeoverlap
#    Changelog = https://pyscaffold.org/en/latest/changelog.html
#    Tracker = https://github.com/pyscaffold/pyscaffold/issues
#    Conda-Forge = https://anaconda.org/conda-forge/pyscaffold
#    Download = https://pypi.org/project/PyScaffold/#files
#    Twitter = https://twitter.com/PyScaffold

# Change if running only on Windows, Mac or Linux (comma-separated)
platforms = any

# Add here all kinds of additional classifiers as defined under
# https://pypi.org/classifiers/
classifiers =
    Development Status :: 4 - Beta
    Programming Language :: Python


[options]
zip_safe = False
packages = find_namespace:
include_package_data = True
package_dir =
    =src

# Require a min/specific Python version (comma-separated conditions)
python_requires = >=3.8

# Add here dependencies of your project (line-separated), e.g. requests>=2.2,<3.0.
# Version specifiers like >=2.2,<3.0 avoid problems due to API changes in
# new major versions. This works if the required packages follow Semantic Versioning.
# For more information, check out https://semver.org/.
install_requires =
    CairoSVG>=2.7.1
    fire>=0.5.0
    lxml>=5.1.0
    picosvg>=0.20.6
    tinycss2>=1.2.1
    tqdm>=4.66.2


[options.packages.find]
where = src
exclude =
    tests

[options.extras_require]
# Add here additional requirements for extra features, to install with:
# `pip install svg_removeoverlap[PDF]` like:
# PDF = ReportLab; RXP

# Add here test requirements (semicolon/line-separated)
testing =
    setuptools>=69.0.0
    pytest>=8.0.0
    pytest-cov>=4.1.0
    mypy>=1.9.0
    # Consider adding lxml-stubs if mypy has trouble with lxml

[options.entry_points]
# Add here console scripts like:
console_scripts =
     svg_removeoverlap = svg_removeoverlap.__main__:cli
# For example:
# console_scripts =
#     fibonacci = svg_removeoverlap.skeleton:run
# And any other entry points, for example:
# pyscaffold.cli =
#     awesome = pyscaffoldext.awesome.extension:AwesomeExtension

[devpi:upload]
# Options for the devpi: PyPI server and packaging tool
# VCS export must be deactivated since we are using setuptools-scm
no_vcs = 1
formats = bdist_wheel

[flake8]
# Some sane defaults for the code style checker flake8
max_line_length = 88
extend_ignore = E203, W503
# ^  Black-compatible
#    E203 and W503 have edge cases handled by black
exclude =
    .tox
    build
    dist
    .eggs
    docs/conf.py

[pyscaffold]
# PyScaffold's parameters when the project was created.
# This will be used when updating. Do not change!
version = 4.4
package = svg_removeoverlap
extensions =
    github_actions
    markdown
    no_skeleton
    no_tox
    pre_commit
</file>

<file path="setup.py">
"""
    Setup file for svg_removeoverlap.
    Use setup.cfg to configure your project.

    This file was generated with PyScaffold 4.4.
    PyScaffold helps you to put up the scaffold of your new Python project.
    Learn more under: https://pyscaffold.org/
"""
from setuptools import setup

if __name__ == "__main__":
    try:
        setup(use_scm_version={"version_scheme": "no-guess-dev"})
    except:  # noqa
        print(
            "\n\nAn error occurred while building the project, "
            "please ensure you have the most updated version of setuptools, "
            "setuptools_scm and wheel with:\n"
            "   pip install -U setuptools setuptools_scm wheel\n\n"
        )
        raise
</file>

</files>
