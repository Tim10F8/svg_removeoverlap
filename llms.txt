This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.github/
  workflows/
    ci.yml
docs/
  _static/
    .gitignore
  authors.md
  changelog.md
  conf.py
  contributing.md
  index.md
  license.md
  Makefile
  readme.md
  requirements.txt
src/
  svg_removeoverlap/
    __init__.py
    __main__.py
    remover.py
  svg_removeoverlap.txt
tests/
  conftest.py
.coveragerc
.gitignore
.isort.cfg
.pre-commit-config.yaml
.readthedocs.yml
AUTHORS.md
LICENSE.txt
pyproject.toml
README.md
setup.cfg
setup.py
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path=".github/workflows/ci.yml">
# GitHub Actions configuration **EXAMPLE**,
# MODIFY IT ACCORDING TO YOUR NEEDS!
# Reference: https://docs.github.com/en/actions

name: tests

on:
  push:
    # Avoid using all the resources/limits available by checking only
    # relevant branches and tags. Other branches can be checked via PRs.
    branches: [main]
    tags: ['v[0-9]*', '[0-9]+.[0-9]+*']  # Match tags that resemble a version
  pull_request:  # Run in every PR
  workflow_dispatch:  # Allow manually triggering the workflow
  schedule:
    # Run roughly every 15 days at 00:00 UTC
    # (useful to check if updates on dependencies break the package)
    - cron: '0 0 1,16 * *'

concurrency:
  group: >-
    ${{ github.workflow }}-${{ github.ref_type }}-
    ${{ github.event.pull_request.number || github.sha }}
  cancel-in-progress: true

jobs:
  prepare:
    runs-on: ubuntu-latest
    outputs:
      wheel-distribution: ${{ steps.wheel-distribution.outputs.path }}
    steps:
      - uses: actions/checkout@v3
        with: {fetch-depth: 0}  # deep clone for setuptools-scm
      - uses: actions/setup-python@v4
        id: setup-python
        with: {python-version: "3.11"}
      - name: Run static analysis and format checkers
        run: pipx run pre-commit run --all-files --show-diff-on-failure
      - name: Build package distribution files
        run: >-
          pipx run --python '${{ steps.setup-python.outputs.python-path }}'
          tox -e clean,build
      - name: Record the path of wheel distribution
        id: wheel-distribution
        run: echo "path=$(ls dist/*.whl)" >> $GITHUB_OUTPUT
      - name: Store the distribution files for use in other stages
        # `tests` and `publish` will use the same pre-built distributions,
        # so we make sure to release the exact same package that was tested
        uses: actions/upload-artifact@v3
        with:
          name: python-distribution-files
          path: dist/
          retention-days: 1

  test:
    needs: prepare
    strategy:
      matrix:
        python:
        - "3.7"  # oldest Python supported by PSF
        - "3.11"  # newest Python that is stable
        platform:
        - ubuntu-latest
        - macos-latest
        - windows-latest
    runs-on: ${{ matrix.platform }}
    steps:
      - uses: actions/checkout@v3
      - uses: actions/setup-python@v4
        id: setup-python
        with:
          python-version: ${{ matrix.python }}
      - name: Retrieve pre-built distribution files
        uses: actions/download-artifact@v3
        with: {name: python-distribution-files, path: dist/}
      - name: Run tests
        run: >-
          pipx run --python '${{ steps.setup-python.outputs.python-path }}'
          tox --installpkg '${{ needs.prepare.outputs.wheel-distribution }}'
          -- -rFEx --durations 10 --color yes  # pytest args
      - name: Generate coverage report
        run: pipx run coverage lcov -o coverage.lcov
      - name: Upload partial coverage report
        uses: coverallsapp/github-action@master
        with:
          path-to-lcov: coverage.lcov
          github-token: ${{ secrets.github_token }}
          flag-name: ${{ matrix.platform }} - py${{ matrix.python }}
          parallel: true

  finalize:
    needs: test
    runs-on: ubuntu-latest
    steps:
      - name: Finalize coverage report
        uses: coverallsapp/github-action@master
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          parallel-finished: true

  publish:
    needs: finalize
    if: ${{ github.event_name == 'push' && contains(github.ref, 'refs/tags/') }}
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - uses: actions/setup-python@v4
        with: {python-version: "3.11"}
      - name: Retrieve pre-built distribution files
        uses: actions/download-artifact@v3
        with: {name: python-distribution-files, path: dist/}
      - name: Publish Package
        env:
          # TODO: Set your PYPI_TOKEN as a secret using GitHub UI
          # - https://pypi.org/help/#apitoken
          # - https://docs.github.com/en/actions/security-guides/encrypted-secrets
          TWINE_REPOSITORY: pypi
          TWINE_USERNAME: __token__
          TWINE_PASSWORD: ${{ secrets.PYPI_TOKEN }}
        run: pipx run tox -e publish
</file>

<file path="docs/_static/.gitignore">
# Empty directory
</file>

<file path="docs/authors.md">
```{include} ../AUTHORS.md
:relative-docs: docs/
:relative-images:
```
</file>

<file path="docs/changelog.md">
```{include} ../CHANGELOG.md
:relative-docs: docs/
:relative-images:
```
</file>

<file path="docs/conf.py">
# This file is execfile()d with the current directory set to its containing dir.
#
# This file only contains a selection of the most common options. For a full
# list see the documentation:
# https://www.sphinx-doc.org/en/master/usage/configuration.html
#
# All configuration values have a default; values that are commented out
# serve to show the default.

import os
import sys
import shutil

# -- Path setup --------------------------------------------------------------

__location__ = os.path.dirname(__file__)

# If extensions (or modules to document with autodoc) are in another directory,
# add these directories to sys.path here. If the directory is relative to the
# documentation root, use os.path.abspath to make it absolute, like shown here.
sys.path.insert(0, os.path.join(__location__, "../src"))

# -- Run sphinx-apidoc -------------------------------------------------------
# This hack is necessary since RTD does not issue `sphinx-apidoc` before running
# `sphinx-build -b html . _build/html`. See Issue:
# https://github.com/readthedocs/readthedocs.org/issues/1139
# DON'T FORGET: Check the box "Install your project inside a virtualenv using
# setup.py install" in the RTD Advanced Settings.
# Additionally it helps us to avoid running apidoc manually

try:  # for Sphinx >= 1.7
    from sphinx.ext import apidoc
except ImportError:
    from sphinx import apidoc

output_dir = os.path.join(__location__, "api")
module_dir = os.path.join(__location__, "../src/svg_removeoverlap")
try:
    shutil.rmtree(output_dir)
except FileNotFoundError:
    pass

try:
    import sphinx

    cmd_line = f"sphinx-apidoc --implicit-namespaces -f -o {output_dir} {module_dir}"

    args = cmd_line.split(" ")
    if tuple(sphinx.__version__.split(".")) >= ("1", "7"):
        # This is a rudimentary parse_version to avoid external dependencies
        args = args[1:]

    apidoc.main(args)
except Exception as e:
    print("Running `sphinx-apidoc` failed!\n{}".format(e))

# -- General configuration ---------------------------------------------------

# If your documentation needs a minimal Sphinx version, state it here.
# needs_sphinx = '1.0'

# Add any Sphinx extension module names here, as strings. They can be extensions
# coming with Sphinx (named 'sphinx.ext.*') or your custom ones.
extensions = [
    "sphinx.ext.autodoc",
    "sphinx.ext.intersphinx",
    "sphinx.ext.todo",
    "sphinx.ext.autosummary",
    "sphinx.ext.viewcode",
    "sphinx.ext.coverage",
    "sphinx.ext.doctest",
    "sphinx.ext.ifconfig",
    "sphinx.ext.mathjax",
    "sphinx.ext.napoleon",
]

# Add any paths that contain templates here, relative to this directory.
templates_path = ["_templates"]


# Enable markdown
extensions.append("myst_parser")

# Configure MyST-Parser
myst_enable_extensions = [
    "amsmath",
    "colon_fence",
    "deflist",
    "dollarmath",
    "html_image",
    "linkify",
    "replacements",
    "smartquotes",
    "substitution",
    "tasklist",
]

# The suffix of source filenames.
source_suffix = [".rst", ".md"]

# The encoding of source files.
# source_encoding = 'utf-8-sig'

# The master toctree document.
master_doc = "index"

# General information about the project.
project = "svg_removeoverlap"
copyright = "2023, twardoch"

# The version info for the project you're documenting, acts as replacement for
# |version| and |release|, also used in various other places throughout the
# built documents.
#
# version: The short X.Y version.
# release: The full version, including alpha/beta/rc tags.
# If you donâ€™t need the separation provided between version and release,
# just set them both to the same value.
try:
    from svg_removeoverlap import __version__ as version
except ImportError:
    version = ""

if not version or version.lower() == "unknown":
    version = os.getenv("READTHEDOCS_VERSION", "unknown")  # automatically set by RTD

release = version

# The language for content autogenerated by Sphinx. Refer to documentation
# for a list of supported languages.
# language = None

# There are two options for replacing |today|: either, you set today to some
# non-false value, then it is used:
# today = ''
# Else, today_fmt is used as the format for a strftime call.
# today_fmt = '%B %d, %Y'

# List of patterns, relative to source directory, that match files and
# directories to ignore when looking for source files.
exclude_patterns = ["_build", "Thumbs.db", ".DS_Store", ".venv"]

# The reST default role (used for this markup: `text`) to use for all documents.
# default_role = None

# If true, '()' will be appended to :func: etc. cross-reference text.
# add_function_parentheses = True

# If true, the current module name will be prepended to all description
# unit titles (such as .. function::).
# add_module_names = True

# If true, sectionauthor and moduleauthor directives will be shown in the
# output. They are ignored by default.
# show_authors = False

# The name of the Pygments (syntax highlighting) style to use.
pygments_style = "sphinx"

# A list of ignored prefixes for module index sorting.
# modindex_common_prefix = []

# If true, keep warnings as "system message" paragraphs in the built documents.
# keep_warnings = False

# If this is True, todo emits a warning for each TODO entries. The default is False.
todo_emit_warnings = True


# -- Options for HTML output -------------------------------------------------

# The theme to use for HTML and HTML Help pages.  See the documentation for
# a list of builtin themes.
html_theme = "alabaster"

# Theme options are theme-specific and customize the look and feel of a theme
# further.  For a list of options available for each theme, see the
# documentation.
html_theme_options = {
    "sidebar_width": "300px",
    "page_width": "1200px"
}

# Add any paths that contain custom themes here, relative to this directory.
# html_theme_path = []

# The name for this set of Sphinx documents.  If None, it defaults to
# "<project> v<release> documentation".
# html_title = None

# A shorter title for the navigation bar.  Default is the same as html_title.
# html_short_title = None

# The name of an image file (relative to this directory) to place at the top
# of the sidebar.
# html_logo = ""

# The name of an image file (within the static path) to use as favicon of the
# docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32
# pixels large.
# html_favicon = None

# Add any paths that contain custom static files (such as style sheets) here,
# relative to this directory. They are copied after the builtin static files,
# so a file named "default.css" will overwrite the builtin "default.css".
html_static_path = ["_static"]

# If not '', a 'Last updated on:' timestamp is inserted at every page bottom,
# using the given strftime format.
# html_last_updated_fmt = '%b %d, %Y'

# If true, SmartyPants will be used to convert quotes and dashes to
# typographically correct entities.
# html_use_smartypants = True

# Custom sidebar templates, maps document names to template names.
# html_sidebars = {}

# Additional templates that should be rendered to pages, maps page names to
# template names.
# html_additional_pages = {}

# If false, no module index is generated.
# html_domain_indices = True

# If false, no index is generated.
# html_use_index = True

# If true, the index is split into individual pages for each letter.
# html_split_index = False

# If true, links to the reST sources are added to the pages.
# html_show_sourcelink = True

# If true, "Created using Sphinx" is shown in the HTML footer. Default is True.
# html_show_sphinx = True

# If true, "(C) Copyright ..." is shown in the HTML footer. Default is True.
# html_show_copyright = True

# If true, an OpenSearch description file will be output, and all pages will
# contain a <link> tag referring to it.  The value of this option must be the
# base URL from which the finished HTML is served.
# html_use_opensearch = ''

# This is the file name suffix for HTML files (e.g. ".xhtml").
# html_file_suffix = None

# Output file base name for HTML help builder.
htmlhelp_basename = "svg_removeoverlap-doc"


# -- Options for LaTeX output ------------------------------------------------

latex_elements = {
    # The paper size ("letterpaper" or "a4paper").
    # "papersize": "letterpaper",
    # The font size ("10pt", "11pt" or "12pt").
    # "pointsize": "10pt",
    # Additional stuff for the LaTeX preamble.
    # "preamble": "",
}

# Grouping the document tree into LaTeX files. List of tuples
# (source start file, target name, title, author, documentclass [howto/manual]).
latex_documents = [
    ("index", "user_guide.tex", "svg_removeoverlap Documentation", "twardoch", "manual")
]

# The name of an image file (relative to this directory) to place at the top of
# the title page.
# latex_logo = ""

# For "manual" documents, if this is true, then toplevel headings are parts,
# not chapters.
# latex_use_parts = False

# If true, show page references after internal links.
# latex_show_pagerefs = False

# If true, show URL addresses after external links.
# latex_show_urls = False

# Documents to append as an appendix to all manuals.
# latex_appendices = []

# If false, no module index is generated.
# latex_domain_indices = True

# -- External mapping --------------------------------------------------------
python_version = ".".join(map(str, sys.version_info[0:2]))
intersphinx_mapping = {
    "sphinx": ("https://www.sphinx-doc.org/en/master", None),
    "python": ("https://docs.python.org/" + python_version, None),
    "matplotlib": ("https://matplotlib.org", None),
    "numpy": ("https://numpy.org/doc/stable", None),
    "sklearn": ("https://scikit-learn.org/stable", None),
    "pandas": ("https://pandas.pydata.org/pandas-docs/stable", None),
    "scipy": ("https://docs.scipy.org/doc/scipy/reference", None),
    "setuptools": ("https://setuptools.pypa.io/en/stable/", None),
    "pyscaffold": ("https://pyscaffold.org/en/stable", None),
}

print(f"loading configurations for {project} {version} ...", file=sys.stderr)
</file>

<file path="docs/contributing.md">
```{include} ../CONTRIBUTING.md
:relative-docs: docs/
:relative-images:
```
</file>

<file path="docs/index.md">
# svg_removeoverlap

CLI tool & Python lib to remove overlap in SVG


## Note

> This is the main page of your project's [Sphinx] documentation. It is
> formatted in [Markdown]. Add additional pages by creating md-files in
> `docs` or rst-files (formatted in [reStructuredText]) and adding links to
> them in the `Contents` section below.
>
> Please check [Sphinx] and [MyST] for more information
> about how to document your project and how to configure your preferences.


## Contents

```{toctree}
:maxdepth: 2

Overview <readme>
Contributions & Help <contributing>
License <license>
Authors <authors>
Changelog <changelog>
Module Reference <api/modules>
```

## Indices and tables

* {ref}`genindex`
* {ref}`modindex`
* {ref}`search`

[Sphinx]: http://www.sphinx-doc.org/
[Markdown]: https://daringfireball.net/projects/markdown/
[reStructuredText]: http://www.sphinx-doc.org/en/master/usage/restructuredtext/basics.html
[MyST]: https://myst-parser.readthedocs.io/en/latest/
</file>

<file path="docs/license.md">
# License

```{literalinclude} ../LICENSE.txt
:language: text
```
</file>

<file path="docs/Makefile">
# Makefile for Sphinx documentation
#

# You can set these variables from the command line, and also
# from the environment for the first two.
SPHINXOPTS    ?=
SPHINXBUILD   ?= sphinx-build
SOURCEDIR     = .
BUILDDIR      = _build
AUTODOCDIR    = api

# User-friendly check for sphinx-build
ifeq ($(shell which $(SPHINXBUILD) >/dev/null 2>&1; echo $?), 1)
$(error "The '$(SPHINXBUILD)' command was not found. Make sure you have Sphinx installed, then set the SPHINXBUILD environment variable to point to the full path of the '$(SPHINXBUILD)' executable. Alternatively you can add the directory with the executable to your PATH. If you don't have Sphinx installed, grab it from https://sphinx-doc.org/")
endif

.PHONY: help clean Makefile

# Put it first so that "make" without argument is like "make help".
help:
	@$(SPHINXBUILD) -M help "$(SOURCEDIR)" "$(BUILDDIR)" $(SPHINXOPTS) $(O)

clean:
	rm -rf $(BUILDDIR)/* $(AUTODOCDIR)

# Catch-all target: route all unknown targets to Sphinx using the new
# "make mode" option.  $(O) is meant as a shortcut for $(SPHINXOPTS).
%: Makefile
	@$(SPHINXBUILD) -M $@ "$(SOURCEDIR)" "$(BUILDDIR)" $(SPHINXOPTS) $(O)
</file>

<file path="docs/readme.md">
```{include} ../README.md
:relative-docs: docs/
:relative-images:
```
</file>

<file path="docs/requirements.txt">
# Requirements file for ReadTheDocs, check .readthedocs.yml.
# To build the module reference correctly, make sure every external package
# under `install_requires` in `setup.cfg` is also listed here!
# sphinx_rtd_theme
myst-parser[linkify]
sphinx>=3.2.1
</file>

<file path="src/svg_removeoverlap/__init__.py">
import sys

if sys.version_info[:2] >= (3, 8):
    # TODO: Import directly (no need for conditional) when `python_requires = >= 3.8`
    from importlib.metadata import PackageNotFoundError, version  # pragma: no cover
else:
    from importlib_metadata import PackageNotFoundError, version  # pragma: no cover

try:
    # Change here if project is renamed and does not equal the package name
    dist_name = __name__
    __version__ = version(dist_name)
except PackageNotFoundError:  # pragma: no cover
    __version__ = "unknown"
finally:
    del version, PackageNotFoundError
</file>

<file path="src/svg_removeoverlap/__main__.py">
#!/usr/bin/env python3
from pathlib import Path
from typing import Union

import fire

from .remover import RemoveOverlapsSVG


def remove_overlaps(
    input_svg: Union[str, Path],
    output_svg: Union[str, Path],
    sequential: bool = False,
    keep_white: bool = False,
    cairo: bool = True,
    picofy: bool = True,
    verbose: bool = False,
) -> None:
    """
    Removes overlapping shapes in an SVG file and saves the result to a new SVG file.

    Args:
        input_svg (Union[str, Path]): Input SVG file path.
        output_svg (Union[str, Path]): Output SVG file path.
        sequential (bool, optional): If True, process shapes sequentially instead of all at once. Defaults to False.
        keep_white (bool, optional): If True, keep white shapes. Defaults to False.
        cairo (bool, optional): If True, use cairo to convert input SVG. Defaults to True.
        picofy (bool, optional): If True, use picosvg to simplify input SVG. Defaults to True.
        verbose (bool, optional): If True, display detailed logging information. Defaults to False.
    """
    remover = RemoveOverlapsSVG(
        cairo=cairo, picofy=picofy, keep_white=keep_white, verbose=verbose
    )
    remover.load_svg(Path(input_svg))
    remover.remove(sequential=sequential)
    remover.save_svg(Path(output_svg))

def cli():
    fire.core.Display = lambda lines, out: print(*lines, file=out)
    fire.Fire(remove_overlaps)

if __name__ == "__main__":
    cli()
</file>

<file path="src/svg_removeoverlap/remover.py">
#!/usr/bin/env python3
import logging
from pathlib import Path
import sys
from typing import List, Union

import picosvg.svg
import picosvg.svg_pathops
from lxml import etree
from tqdm import tqdm
import tinycss2

logger = logging.getLogger(__name__)

from lxml import etree

def get_css_fill(style: str) -> str:
    """Extract the fill value from a CSS style string.

    Args:
        style (str): The CSS style string.

    Returns:
        str: The fill value found in the CSS style string.
    """
    try:
        return (
            next(
                (
                    token.value[0].serialize()
                    for token in tinycss2.parse_declaration_list(style)
                    if hasattr(token, "name") and token.name == "fill"
                ),
                "",
            )
            .replace(" ", "")
            .lower()
        )
    except ValueError:
        return ""

class RemoveOverlapsSVG:
    def __init__(
        self,
        cairo: bool = True,
        picofy: bool = False,
        keep_white: bool = False,
        skip_svg_fills: List[str] = None,
        verbose: bool = False,
    ) -> None:
        """Initialize RemoveOverlapsSVG class.

        Args:
            cairo (bool, optional): Use CairoSVG for SVG conversion. Defaults to True.
            picofy (bool, optional): Convert SVG to picosvg. Defaults to False.
            keep_white (bool, optional): Keep white fill shapes. Defaults to False.
            skip_svg_fills (List[str], optional): List of fill values to skip. Defaults to a list of common white and transparent fill values.
            verbose (bool, optional): Enable verbose logging. Defaults to False.
        """
        self.skip_svg_fills: List[str] = skip_svg_fills or [
            "white",
            "rgb(255,255,255)",
            "rgb(100%,100%,100%)",
            "rgba(255,255,255,1)",
            "hsl(0,0%,100%)",
            "hsla(0,0%,100%,1)",
            "transparent",
            "#ffffff",
            "none",
        ]
        self.cairo: bool = cairo
        self.picofy: bool = picofy
        self.keep_white: bool = keep_white
        self.verbose: bool = verbose
        if verbose:
            logging.basicConfig(level=logging.INFO)
        self.svg_content: str = None
        self.pico: picosvg.svg.SVG = None

    def _protect_clipPaths(self, svg_bytes: bytes) -> str:
        """Protect clipPaths by setting their fill to transparent.

        Args:
            svg_bytes (bytes): SVG content as bytes.

        Returns:
            str: Modified SVG content as string.
        """
        try:
            root = etree.fromstring(svg_bytes)
        except (etree.XMLSyntaxError, etree.LxmlError) as err:
            raise ValueError(f"Invalid SVG content: {err}") from err
        clip_paths = root.findall(".//{http://www.w3.org/2000/svg}clipPath")
        for clip_path in clip_paths:
            paths = clip_path.findall("{http://www.w3.org/2000/svg}path")
            for path in paths:
                path.set("fill", "transparent")
        return etree.tostring(root, encoding="UTF-8", xml_declaration=True).decode(
            "utf-8"
        )

    def _prep_svg_cairo(self) -> None:
        """Prepare the SVG content for CairoSVG conversion."""
        from cairosvg.surface import SVGSurface

        try:
            self.svg_content = self._protect_clipPaths(
                SVGSurface.convert(bytestring=bytes(self.svg_content, encoding="utf-8"))
            )
        except Exception as e:
            print(f"Error: {e}")
            print("Error: SVG content:")
            print(self.svg_content)
        else:
            print("CairoSVG conversion successful")

    def save_svg(self, output_path: Union[str, Path]) -> None:
        """Save the SVG content to a file.

        Args:
            output_path (Union[str, Path]): The path of the output file.
        """
        output_path = Path(output_path)
        output_path.parent.mkdir(parents=True, exist_ok=True)
        logger.info(f"Saving {output_path}...")
        with open(output_path, "w") as output_file:
            output_file.write(self.svg_content)

    def load_svg(self, input_path: Union[str, Path]) -> None:
        """Load an SVG file and read its content.

        Args:
            input_path (Union[str, Path]): The path of the input file.
        """
        if not input_path:
            raise ValueError("The input path cannot be empty.")

        input_path = Path(input_path)

        if not input_path.exists():
            raise FileNotFoundError(f"The input path {input_path} does not exist.")

        if not input_path.is_file():
            raise NotADirectoryError(f"The input path {input_path} is not a file.")

        logger.info(f"Reading {input_path}...")
        with open(input_path, "r") as svg_file:
            self.svg_content = svg_file.read()
        if self.cairo:
            self._prep_svg_cairo()

    def _parse_svg(self):
        """Parse the SVG content and create an SVG object using picosvg."""
        logger.info("Parsing SVG...")
        try:
            self.pico = picosvg.svg.SVG.fromstring(self.svg_content)
        except (picosvg.svg.SVGParseError, ValueError) as e:
            logger.error(f"Failed to parse SVG: {e}")
            raise

    def _picofy_svg(self):
        """Convert the SVG object to a picosvg representation if the 'picofy' option is enabled."""
        if self.picofy:
            logger.info("Picofying SVG...")
            try:
                self.pico = self.pico.topicosvg()
                self.svg_content = self.pico.tostring(pretty_print=False)
            except Exception as e:
                logger.warn("Failed to picofy SVG: %s", e)

    def _prep_pico(self):
        """Prepare the picosvg object by parsing the SVG content and optionally converting it to a picosvg representation."""
        try:
            self._parse_svg()
            self._picofy_svg()
        except Exception as e:
            self._picosvg = None
            self._picosvg_error = e

    def _filter_pico_shapes(self):
        """Filter the shapes in the picosvg object based on their fill values.

        Returns:
            List[picosvg.svg.Shapes]: A list of filtered shapes.
        """
        shapes = []
        for shape in tqdm(
            self.pico.shapes(),
            desc="Converting paths",
            disable=not self.verbose or not sys.stdout.isatty(),
        ):
            fill = get_css_fill(shape.style) or shape.fill.replace(" ", "").lower()
            if (self.keep_white) or (fill not in self.skip_svg_fills):
                shapes.append(shape)
        return shapes


    def remove_overlaps_pico(self, sequential: bool = False) -> None:
        """Remove overlaps in the SVG using picosvg.

        Args:
            sequential (bool, optional): Remove overlaps sequentially. Defaults to False.
        """
        self._prep_pico()
        shapes = self._filter_pico_shapes()
        clip_rule = "nonzero"
        clip_rules = [clip_rule] * len(shapes)

        if sequential:
            new_shape = shapes[0]
            for shape in tqdm(
                shapes[1:],
                desc="Removing overlaps",
                disable=not self.verbose or not sys.stdout.isatty(),
            ):
                new_shape = picosvg.svg_pathops.union(
                    [new_shape, shape], [clip_rule, clip_rule]
                )
        else:
            logger.info("Removing overlaps...")
            new_shape = picosvg.svg_pathops.union(shapes, clip_rules)
        union_d = picosvg.svg.SVGPath.from_commands(new_shape).d
        new_root = etree.Element("svg")
        for a, v in self.pico.svg_root.attrib.items():
            new_root.set(a, v)
        new_root.set("xmlns", "http://www.w3.org/2000/svg")
        new_svg = picosvg.svg.SVG(new_root)
        new_svg.view_box = self.pico.view_box
        path_el = etree.SubElement(new_root, "path")
        path_el.set("d", union_d)
        self.pico = new_svg
        self.svg_content = self.pico.tostring(pretty_print=True)

    def remove(self, sequential: bool = False) -> None:
        """Remove overlaps in the SVG.

        Args:
            sequential (bool, optional): Remove overlaps sequentially. Defaults to False.
        """
        self.remove_overlaps_pico(sequential=sequential)
</file>

<file path="src/svg_removeoverlap.txt">
=== file: __init__.py ===

```
 import sys

 if sys.version_info[:2] >= (3, 8):
     # TODO: Import directly (no need for conditional) when `python_requires = >= 3.8`
     from importlib.metadata import PackageNotFoundError, version  # pragma: no cover
 else:
     from importlib_metadata import PackageNotFoundError, version  # pragma: no cover

 try:
     # Change here if project is renamed and does not equal the package name
     dist_name = __name__
     __version__ = version(dist_name)
 except PackageNotFoundError:  # pragma: no cover
     __version__ = "unknown"
 finally:
     del version, PackageNotFoundError

```

=== file: __main__.py ===

```
 #!/usr/bin/env python3
 import fire
 from .remover import RemoveOverlapsSVG

 def remove_overlaps(
     input_svg,
     output_svg,
     sequential=False,
     keep_white=False,
     cairo=True,
     picofy=False,
     verbose=False,
 ):
     remover = RemoveOverlapsSVG(
         cairo=cairo, picofy=picofy, keep_white=keep_white, verbose=verbose
     )
     remover.load_svg(Path(input_svg))
     remover.remove(sequential=sequential)
     remover.save_svg(Path(output_svg))

 if __name__ == "__main__":
     fire.core.Display = lambda lines, out: print(*lines, file=out)
     fire.Fire(remove_overlaps)

```

=== file: remover.py ===

```
 #!/usr/bin/env python3
 import logging
 from pathlib import Path
 import sys
 from typing import List, Union

 import picosvg.svg
 import picosvg.svg_pathops
 from lxml import etree
 from tqdm import tqdm
 import tinycss2


 logger = logging.getLogger(__name__)

 from lxml import etree


 def get_css_fill(style):
     return (
         next(
             (
                 token.value[0].serialize()
                 for token in tinycss2.parse_declaration_list(style)
                 if hasattr(token, "name") and token.name == "fill"
             ),
             "",
         )
         .replace(" ", "")
         .lower()
     )


 class RemoveOverlapsSVG:
     def __init__(
         self,
         cairo: bool = True,
         picofy: bool = False,
         keep_white: bool = False,
         skip_svg_fills: List[str] = None,
         verbose: bool = False,
     ) -> None:
         self.skip_svg_fills: List[str] = skip_svg_fills or [
             "white",
             "rgb(255,255,255)",
             "rgb(100%,100%,100%)",
             "rgba(255,255,255,1)",
             "hsl(0,0%,100%)",
             "hsla(0,0%,100%,1)",
             "transparent",
             "rgba(0,0,0,0)",
             "hsla(0,0%,0%,0)",
             "#ffffff",
             "none",
         ]
         self.cairo: bool = cairo
         self.picofy: bool = picofy
         self.keep_white: bool = keep_white
         self.verbose: bool = verbose
         if verbose:
             logging.basicConfig(level=logging.INFO)
         self.svg_content: str = None
         self.pico: picosvg.svg.SVG = None

     def _protect_clipPaths(self, svg_bytes):
         root = etree.fromstring(svg_bytes)
         clip_paths = root.findall(".//{http://www.w3.org/2000/svg}clipPath")
         for clip_path in clip_paths:
             paths = clip_path.findall("{http://www.w3.org/2000/svg}path")
             for path in paths:
                 path.set("fill", "transparent")
         return etree.tostring(root, encoding="UTF-8", xml_declaration=True).decode(
             "utf-8"
         )

     def _prep_svg_cairo(self) -> str:
         from cairosvg.surface import SVGSurface

         self.svg_content = self._protect_clipPaths(
             SVGSurface.convert(bytestring=bytes(self.svg_content, encoding="utf-8"))
         )

     def save_svg(self, output_path: Union[str, Path]) -> None:
         logger.info(f"Saving {output_path}...")
         with open(output_path, "w") as output_file:
             output_file.write(self.svg_content)

     def load_svg(self, input_path: Union[str, Path]) -> None:
         logger.info(f"Reading {input_path}...")
         with open(input_path, "r") as svg_file:
             self.svg_content = svg_file.read()
         if self.cairo:
             self._prep_svg_cairo()

     def _parse_svg(self):
         logger.info("Parsing SVG...")
         self.pico = picosvg.svg.SVG.fromstring(self.svg_content)

     def _picofy_svg(self):
         if self.picofy:
             logger.info("Picofying SVG...")
             self.pico = self.pico.topicosvg()
             self.svg_content = self.pico.tostring(pretty_print=False)

     def _prep_pico(self):
         self._parse_svg()
         self._picofy_svg()

     def _filter_pico_shapes(self):
         shapes = []
         for shape in tqdm(
             self.pico.shapes(),
             desc="Converting paths",
             disable=not self.verbose or not sys.stdout.isatty(),
         ):
             fill = get_css_fill(shape.style) or shape.fill.replace(" ", "").lower()
             if (self.keep_white) or (fill not in self.skip_svg_fills):
                 shapes.append(shape)
         return shapes

     def remove_overlaps_pico(
         self,
         sequential: bool = False,
     ) -> None:
         self._prep_pico()
         shapes = self._filter_pico_shapes()
         clip_rule = "nonzero"
         clip_rules = [clip_rule] * len(shapes)

         if sequential:
             new_shape = shapes[0]
             for shape in tqdm(
                 shapes[1:],
                 desc="Removing overlaps",
                 disable=not self.verbose or not sys.stdout.isatty(),
             ):
                 new_shape = picosvg.svg_pathops.union(
                     [new_shape, shape], [clip_rule, clip_rule]
                 )
         else:
             logger.info("Removing overlaps...")
             new_shape = picosvg.svg_pathops.union(shapes, clip_rules)
         union_d = picosvg.svg.SVGPath.from_commands(new_shape).d
         new_root = etree.Element("svg")
         for a, v in self.pico.svg_root.attrib.items():
             new_root.set(a, v)
         new_root.set("xmlns", "http://www.w3.org/2000/svg")
         new_svg = picosvg.svg.SVG(new_root)
         new_svg.view_box = self.pico.view_box
         path_el = etree.SubElement(new_root, "path")
         path_el.set("d", union_d)
         self.pico = new_svg
         self.svg_content = self.pico.tostring(pretty_print=True)

     def remove(
         self,
         sequential: bool = False,
     ) -> None:
         self.remove_overlaps_pico(sequential=sequential)


```

 #!/usr/bin/env python3
 import logging
 from pathlib import Path
 import sys
 from typing import List, Union

 import picosvg.svg
 import picosvg.svg_pathops
 from lxml import etree
 from tqdm import tqdm
 import tinycss2


 logger = logging.getLogger(__name__)

 from lxml import etree


 def get_css_fill(style):
     return (
         next(
             (
                 token.value[0].serialize()
                 for token in tinycss2.parse_declaration_list(style)
                 if hasattr(token, "name") and token.name == "fill"
             ),
             "",
         )
         .replace(" ", "")
         .lower()
     )


 class RemoveOverlapsSVG:
     def __init__(
         self,
         cairo: bool = True,
         picofy: bool = False,
         keep_white: bool = False,
         skip_svg_fills: List[str] = None,
         verbose: bool = False,
     ) -> None:
         self.skip_svg_fills: List[str] = skip_svg_fills or [
             "white",
             "rgb(255,255,255)",
             "rgb(100%,100%,100%)",
             "rgba(255,255,255,1)",
             "hsl(0,0%,100%)",
             "hsla(0,0%,100%,1)",
             "transparent",
             "rgba(0,0,0,0)",
             "hsla(0,0%,0%,0)",
             "#ffffff",
             "none",
         ]
         self.cairo: bool = cairo
         self.picofy: bool = picofy
         self.keep_white: bool = keep_white
         self.verbose: bool = verbose
         if verbose:
             logging.basicConfig(level=logging.INFO)
         self.svg_content: str = None
         self.pico: picosvg.svg.SVG = None

     def _protect_clipPaths(self, svg_bytes):
         root = etree.fromstring(svg_bytes)
         clip_paths = root.findall(".//{http://www.w3.org/2000/svg}clipPath")
         for clip_path in clip_paths:
             paths = clip_path.findall("{http://www.w3.org/2000/svg}path")
             for path in paths:
                 path.set("fill", "transparent")
         return etree.tostring(root, encoding="UTF-8", xml_declaration=True).decode(
             "utf-8"
         )

     def _prep_svg_cairo(self) -> str:
         from cairosvg.surface import SVGSurface

         self.svg_content = self._protect_clipPaths(
             SVGSurface.convert(bytestring=bytes(self.svg_content, encoding="utf-8"))
         )

     def save_svg(self, output_path: Union[str, Path]) -> None:
         logger.info(f"Saving {output_path}...")
         with open(output_path, "w") as output_file:
             output_file.write(self.svg_content)

     def load_svg(self, input_path: Union[str, Path]) -> None:
         logger.info(f"Reading {input_path}...")
         with open(input_path, "r") as svg_file:
             self.svg_content = svg_file.read()
         if self.cairo:
             self._prep_svg_cairo()

     def _parse_svg(self):
         logger.info("Parsing SVG...")
         self.pico = picosvg.svg.SVG.fromstring(self.svg_content)

     def _picofy_svg(self):
         if self.picofy:
             logger.info("Picofying SVG...")
             self.pico = self.pico.topicosvg()
             self.svg_content = self.pico.tostring(pretty_print=False)

     def _prep_pico(self):
         self._parse_svg()
         self._picofy_svg()

     def _filter_pico_shapes(self):
         shapes = []
         for shape in tqdm(
             self.pico.shapes(),
             desc="Converting paths",
             disable=not self.verbose or not sys.stdout.isatty(),
         ):
             fill = get_css_fill(shape.style) or shape.fill.replace(" ", "").lower()
             if (self.keep_white) or (fill not in self.skip_svg_fills):
                 shapes.append(shape)
         return shapes

     def remove_overlaps_pico(
         self,
         sequential: bool = False,
     ) -> None:
         self._prep_pico()
         shapes = self._filter_pico_shapes()
         clip_rule = "nonzero"
         clip_rules = [clip_rule] * len(shapes)

         if sequential:
             new_shape = shapes[0]
             for shape in tqdm(
                 shapes[1:],
                 desc="Removing overlaps",
                 disable=not self.verbose or not sys.stdout.isatty(),
             ):
                 new_shape = picosvg.svg_pathops.union(
                     [new_shape, shape], [clip_rule, clip_rule]
                 )
         else:
             logger.info("Removing overlaps...")
             new_shape = picosvg.svg_pathops.union(shapes, clip_rules)
         union_d = picosvg.svg.SVGPath.from_commands(new_shape).d
         new_root = etree.Element("svg")
         for a, v in self.pico.svg_root.attrib.items():
             new_root.set(a, v)
         new_root.set("xmlns", "http://www.w3.org/2000/svg")
         new_svg = picosvg.svg.SVG(new_root)
         new_svg.view_box = self.pico.view_box
         path_el = etree.SubElement(new_root, "path")
         path_el.set("d", union_d)
         self.pico = new_svg
         self.svg_content = self.pico.tostring(pretty_print=True)

     def remove(
         self,
         sequential: bool = False,
     ) -> None:
         self.remove_overlaps_pico(sequential=sequential)


```

===
</file>

<file path="tests/conftest.py">
"""
    Dummy conftest.py for svg_removeoverlap.

    If you don't know what this is for, just leave it empty.
    Read more about conftest.py under:
    - https://docs.pytest.org/en/stable/fixture.html
    - https://docs.pytest.org/en/stable/writing_plugins.html
"""

# import pytest
</file>

<file path=".coveragerc">
# .coveragerc to control coverage.py
[run]
branch = True
source = svg_removeoverlap
# omit = bad_file.py

[paths]
source =
    src/
    */site-packages/

[report]
# Regexes for lines to exclude from consideration
exclude_lines =
    # Have to re-enable the standard pragma
    pragma: no cover

    # Don't complain about missing debug-only code:
    def __repr__
    if self\.debug

    # Don't complain if tests don't hit defensive assertion code:
    raise AssertionError
    raise NotImplementedError

    # Don't complain if non-runnable code isn't run:
    if 0:
    if __name__ == .__main__.:
</file>

<file path=".gitignore">
.DS_Store

# Temporary and binary files
*~
*.py[cod]
*.so
*.cfg
!.isort.cfg
!setup.cfg
*.orig
*.log
*.pot
__pycache__/*
.cache/*
.*.swp
*/.ipynb_checkpoints/*
.DS_Store

# Project files
.ropeproject
.project
.pydevproject
.settings
.idea
.vscode
tags

# Package files
*.egg
*.eggs/
.installed.cfg
*.egg-info

# Unittest and coverage
htmlcov/*
.coverage
.coverage.*
.tox
junit*.xml
coverage.xml
.pytest_cache/

# Build and docs folder/files
build/*
dist/*
sdist/*
docs/api/*
docs/_rst/*
docs/_build/*
cover/*
MANIFEST

# Per-project virtualenvs
.venv*/
.conda*/
.python-version
</file>

<file path=".isort.cfg">
[settings]
profile = black
known_first_party = svg_removeoverlap
</file>

<file path=".pre-commit-config.yaml">
exclude: '^docs/conf.py'

repos:
- repo: https://github.com/pre-commit/pre-commit-hooks
  rev: v4.4.0
  hooks:
  - id: trailing-whitespace
  - id: check-added-large-files
  - id: check-ast
  - id: check-json
  - id: check-merge-conflict
  - id: check-xml
  - id: check-yaml
  - id: debug-statements
  - id: end-of-file-fixer
  - id: requirements-txt-fixer
  - id: mixed-line-ending
    args: ['--fix=auto']  # replace 'auto' with 'lf' to enforce Linux/Mac line endings or 'crlf' for Windows

## If you want to automatically "modernize" your Python code:
# - repo: https://github.com/asottile/pyupgrade
#   rev: v3.3.1
#   hooks:
#   - id: pyupgrade
#     args: ['--py37-plus']

## If you want to avoid flake8 errors due to unused vars or imports:
# - repo: https://github.com/PyCQA/autoflake
#   rev: v2.0.0
#   hooks:
#   - id: autoflake
#     args: [
#       --in-place,
#       --remove-all-unused-imports,
#       --remove-unused-variables,
#     ]

- repo: https://github.com/PyCQA/isort
  rev: 5.11.4
  hooks:
  - id: isort

- repo: https://github.com/psf/black
  rev: stable
  hooks:
  - id: black
    language_version: python3

## If like to embrace black styles even in the docs:
# - repo: https://github.com/asottile/blacken-docs
#   rev: v1.13.0
#   hooks:
#   - id: blacken-docs
#     additional_dependencies: [black]

- repo: https://github.com/PyCQA/flake8
  rev: 5.0.4
  hooks:
  - id: flake8
  ## You can add flake8 plugins via `additional_dependencies`:
  #  additional_dependencies: [flake8-bugbear]

## Check for misspells in documentation files:
# - repo: https://github.com/codespell-project/codespell
#   rev: v2.2.2
#   hooks:
#   - id: codespell
</file>

<file path=".readthedocs.yml">
# Read the Docs configuration file
# See https://docs.readthedocs.io/en/stable/config-file/v2.html for details

# Required
version: 2

# Build documentation in the docs/ directory with Sphinx
sphinx:
  configuration: docs/conf.py

# Build documentation with MkDocs
#mkdocs:
#  configuration: mkdocs.yml

# Optionally build your docs in additional formats such as PDF
formats:
  - pdf

build:
  os: ubuntu-22.04
  tools:
    python: "3.11"

python:
  install:
    - requirements: docs/requirements.txt
    - {path: ., method: pip}
</file>

<file path="AUTHORS.md">
# Contributors

- Adam Twardoch <adam+github@twardoch.com>
</file>

<file path="LICENSE.txt">
Apache License
                           Version 2.0, January 2004
                        http://www.apache.org/licenses/

   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION

   1. Definitions.

      "License" shall mean the terms and conditions for use, reproduction,
      and distribution as defined by Sections 1 through 9 of this document.

      "Licensor" shall mean the copyright owner or entity authorized by
      the copyright owner that is granting the License.

      "Legal Entity" shall mean the union of the acting entity and all
      other entities that control, are controlled by, or are under common
      control with that entity. For the purposes of this definition,
      "control" means (i) the power, direct or indirect, to cause the
      direction or management of such entity, whether by contract or
      otherwise, or (ii) ownership of fifty percent (50%) or more of the
      outstanding shares, or (iii) beneficial ownership of such entity.

      "You" (or "Your") shall mean an individual or Legal Entity
      exercising permissions granted by this License.

      "Source" form shall mean the preferred form for making modifications,
      including but not limited to software source code, documentation
      source, and configuration files.

      "Object" form shall mean any form resulting from mechanical
      transformation or translation of a Source form, including but
      not limited to compiled object code, generated documentation,
      and conversions to other media types.

      "Work" shall mean the work of authorship, whether in Source or
      Object form, made available under the License, as indicated by a
      copyright notice that is included in or attached to the work
      (an example is provided in the Appendix below).

      "Derivative Works" shall mean any work, whether in Source or Object
      form, that is based on (or derived from) the Work and for which the
      editorial revisions, annotations, elaborations, or other modifications
      represent, as a whole, an original work of authorship. For the purposes
      of this License, Derivative Works shall not include works that remain
      separable from, or merely link (or bind by name) to the interfaces of,
      the Work and Derivative Works thereof.

      "Contribution" shall mean any work of authorship, including
      the original version of the Work and any modifications or additions
      to that Work or Derivative Works thereof, that is intentionally
      submitted to Licensor for inclusion in the Work by the copyright owner
      or by an individual or Legal Entity authorized to submit on behalf of
      the copyright owner. For the purposes of this definition, "submitted"
      means any form of electronic, verbal, or written communication sent
      to the Licensor or its representatives, including but not limited to
      communication on electronic mailing lists, source code control systems,
      and issue tracking systems that are managed by, or on behalf of, the
      Licensor for the purpose of discussing and improving the Work, but
      excluding communication that is conspicuously marked or otherwise
      designated in writing by the copyright owner as "Not a Contribution."

      "Contributor" shall mean Licensor and any individual or Legal Entity
      on behalf of whom a Contribution has been received by Licensor and
      subsequently incorporated within the Work.

   2. Grant of Copyright License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      copyright license to reproduce, prepare Derivative Works of,
      publicly display, publicly perform, sublicense, and distribute the
      Work and such Derivative Works in Source or Object form.

   3. Grant of Patent License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      (except as stated in this section) patent license to make, have made,
      use, offer to sell, sell, import, and otherwise transfer the Work,
      where such license applies only to those patent claims licensable
      by such Contributor that are necessarily infringed by their
      Contribution(s) alone or by combination of their Contribution(s)
      with the Work to which such Contribution(s) was submitted. If You
      institute patent litigation against any entity (including a
      cross-claim or counterclaim in a lawsuit) alleging that the Work
      or a Contribution incorporated within the Work constitutes direct
      or contributory patent infringement, then any patent licenses
      granted to You under this License for that Work shall terminate
      as of the date such litigation is filed.

   4. Redistribution. You may reproduce and distribute copies of the
      Work or Derivative Works thereof in any medium, with or without
      modifications, and in Source or Object form, provided that You
      meet the following conditions:

      (a) You must give any other recipients of the Work or
          Derivative Works a copy of this License; and

      (b) You must cause any modified files to carry prominent notices
          stating that You changed the files; and

      (c) You must retain, in the Source form of any Derivative Works
          that You distribute, all copyright, patent, trademark, and
          attribution notices from the Source form of the Work,
          excluding those notices that do not pertain to any part of
          the Derivative Works; and

      (d) If the Work includes a "NOTICE" text file as part of its
          distribution, then any Derivative Works that You distribute must
          include a readable copy of the attribution notices contained
          within such NOTICE file, excluding those notices that do not
          pertain to any part of the Derivative Works, in at least one
          of the following places: within a NOTICE text file distributed
          as part of the Derivative Works; within the Source form or
          documentation, if provided along with the Derivative Works; or,
          within a display generated by the Derivative Works, if and
          wherever such third-party notices normally appear. The contents
          of the NOTICE file are for informational purposes only and
          do not modify the License. You may add Your own attribution
          notices within Derivative Works that You distribute, alongside
          or as an addendum to the NOTICE text from the Work, provided
          that such additional attribution notices cannot be construed
          as modifying the License.

      You may add Your own copyright statement to Your modifications and
      may provide additional or different license terms and conditions
      for use, reproduction, or distribution of Your modifications, or
      for any such Derivative Works as a whole, provided Your use,
      reproduction, and distribution of the Work otherwise complies with
      the conditions stated in this License.

   5. Submission of Contributions. Unless You explicitly state otherwise,
      any Contribution intentionally submitted for inclusion in the Work
      by You to the Licensor shall be under the terms and conditions of
      this License, without any additional terms or conditions.
      Notwithstanding the above, nothing herein shall supersede or modify
      the terms of any separate license agreement you may have executed
      with Licensor regarding such Contributions.

   6. Trademarks. This License does not grant permission to use the trade
      names, trademarks, service marks, or product names of the Licensor,
      except as required for reasonable and customary use in describing the
      origin of the Work and reproducing the content of the NOTICE file.

   7. Disclaimer of Warranty. Unless required by applicable law or
      agreed to in writing, Licensor provides the Work (and each
      Contributor provides its Contributions) on an "AS IS" BASIS,
      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
      implied, including, without limitation, any warranties or conditions
      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
      PARTICULAR PURPOSE. You are solely responsible for determining the
      appropriateness of using or redistributing the Work and assume any
      risks associated with Your exercise of permissions under this License.

   8. Limitation of Liability. In no event and under no legal theory,
      whether in tort (including negligence), contract, or otherwise,
      unless required by applicable law (such as deliberate and grossly
      negligent acts) or agreed to in writing, shall any Contributor be
      liable to You for damages, including any direct, indirect, special,
      incidental, or consequential damages of any character arising as a
      result of this License or out of the use or inability to use the
      Work (including but not limited to damages for loss of goodwill,
      work stoppage, computer failure or malfunction, or any and all
      other commercial damages or losses), even if such Contributor
      has been advised of the possibility of such damages.

   9. Accepting Warranty or Additional Liability. While redistributing
      the Work or Derivative Works thereof, You may choose to offer,
      and charge a fee for, acceptance of support, warranty, indemnity,
      or other liability obligations and/or rights consistent with this
      License. However, in accepting such obligations, You may act only
      on Your own behalf and on Your sole responsibility, not on behalf
      of any other Contributor, and only if You agree to indemnify,
      defend, and hold each Contributor harmless for any liability
      incurred by, or claims asserted against, such Contributor by reason
      of your accepting any such warranty or additional liability.

   END OF TERMS AND CONDITIONS

   APPENDIX: How to apply the Apache License to your work.

      To apply the Apache License to your work, attach the following
      boilerplate notice, with the fields enclosed by brackets "{}"
      replaced with your own identifying information. (Don't include
      the brackets!)  The text should be enclosed in the appropriate
      comment syntax for the file format. We also recommend that a
      file or class name and description of purpose be included on the
      same "printed page" as the copyright notice for easier
      identification within third-party archives.

   Copyright {yyyy} {name of copyright owner}

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
</file>

<file path="pyproject.toml">
[build-system]
# AVOID CHANGING REQUIRES: IT WILL BE UPDATED BY PYSCAFFOLD!
requires = ["setuptools>=46.1.0", "setuptools_scm[toml]>=5"]
build-backend = "setuptools.build_meta"

[tool.setuptools_scm]
# For smarter version schemes and other configuration options,
# check out https://github.com/pypa/setuptools_scm
version_scheme = "no-guess-dev"
</file>

<file path="README.md">
# svg_removeoverlap

CLI tool & Python lib to remove overlap in SVG.

This Python script is designed to remove overlapping shapes in an SVG (Scalable Vector Graphics) file using the picosvg library. It provides several options to control the removal process, such as using CairoSVG for SVG conversion, converting SVG to picosvg, keeping white fill shapes, and skipping specific fill values.

## Installation

```bash
python3 -m pip install --upgrade git+https://github.com/twardoch/svg_removeoverlap
```

You also need to install external dependencies.

### On macOS

With [Homebrew](https://brew.sh/)

```bash
brew install cairo libffi pkg-config
```

### On Windows

With [vcpkg](https://github.com/microsoft/vcpkg):

```
vcpkg install cairo:x64-windows
vcpkg install libffi:x64-windows
vcpkg install pkg-config:x64-windows
```

With [Chocolatey](https://chocolatey.org/install):

```
choco install cairo
choco install pkgconfiglite
```

### On Ubuntu

```bash
sudo apt-get install libcairo2-dev libffi-dev pkg-config
```


## Usage in CLI

```bash
svg_removeoverlap input.svg output.svg
```

```
$ svg_removeoverlap --help
INFO: Showing help with the command 'svg_removeoverlap -- --help'.

NAME
    svg_removeoverlap - Removes overlapping shapes in an SVG file and saves the result to a new SVG file.

SYNOPSIS
    svg_removeoverlap INPUT_SVG OUTPUT_SVG <flags>

DESCRIPTION
    Removes overlapping shapes in an SVG file and saves the result to a new SVG file.

POSITIONAL ARGUMENTS
    INPUT_SVG
        Type: Union
        Input SVG file path.
    OUTPUT_SVG
        Type: Union
        Output SVG file path.

FLAGS
    -s, --sequential=SEQUENTIAL
        Type: bool
        Default: False
        If True, process shapes sequentially instead of all at once. Defaults to False.
    -k, --keep_white=KEEP_WHITE
        Type: bool
        Default: False
        If True, keep white shapes. Defaults to False.
    -c, --cairo=CAIRO
        Type: bool
        Default: True
        If True, use cairo to convert input SVG. Defaults to True.
    -p, --picofy=PICOFY
        Type: bool
        Default: False
        If True, use picosvg to simplify input SVG. Defaults to False.
    -v, --verbose=VERBOSE
        Type: bool
        Default: False
        If True, display detailed logging information. Defaults to False.

NOTES
    You can also use flags syntax for POSITIONAL ARGUMENTS
```

## Usage in Python

```python
from svg_removeoverlap.remover import RemoveOverlapsSVG
remover = RemoveOverlapsSVG(cairo=True, picofy=False, keep_white=False, verbose=True)
remover.load_svg(input_path)
remover.remove(sequential=False)
remover.save_svg(output_path)
```

## License

- Copyright (c) 2023 Adam Twardoch
- Licensed under the [Apache 2.0](./LICENSE.txt) license.
</file>

<file path="setup.cfg">
# This file is used to configure your project.
# Read more about the various options under:
# https://setuptools.pypa.io/en/latest/userguide/declarative_config.html
# https://setuptools.pypa.io/en/latest/references/keywords.html

[metadata]
name = svg_removeoverlap
description = CLI tool & Python lib to remove overlap in SVG
author = Adam Twardoch
author_email = adam+github@twardoch.com
license = Apache-2.0
license_files = LICENSE.txt
long_description = file: README.md
long_description_content_type = text/markdown; charset=UTF-8; variant=GFM
url = https://github.com/twardoch/svg_removeoverlap
# Add here related links, for example:
project_urls =
    Documentation = https://github.com/twardoch/svg_removeoverlap
    Source = https://github.com/twardoch/svg_removeoverlap
#    Changelog = https://pyscaffold.org/en/latest/changelog.html
#    Tracker = https://github.com/pyscaffold/pyscaffold/issues
#    Conda-Forge = https://anaconda.org/conda-forge/pyscaffold
#    Download = https://pypi.org/project/PyScaffold/#files
#    Twitter = https://twitter.com/PyScaffold

# Change if running only on Windows, Mac or Linux (comma-separated)
platforms = any

# Add here all kinds of additional classifiers as defined under
# https://pypi.org/classifiers/
classifiers =
    Development Status :: 4 - Beta
    Programming Language :: Python


[options]
zip_safe = False
packages = find_namespace:
include_package_data = True
package_dir =
    =src

# Require a min/specific Python version (comma-separated conditions)
# python_requires = >=3.8

# Add here dependencies of your project (line-separated), e.g. requests>=2.2,<3.0.
# Version specifiers like >=2.2,<3.0 avoid problems due to API changes in
# new major versions. This works if the required packages follow Semantic Versioning.
# For more information, check out https://semver.org/.
install_requires =
    importlib-metadata; python_version<"3.8"
    CairoSVG>=2.6.0
    fire>=0.5.0
    lxml>=4.9.2
    picosvg>=0.20.6
    tinycss2>=1.2.1
    tqdm>=4.65.0


[options.packages.find]
where = src
exclude =
    tests

[options.extras_require]
# Add here additional requirements for extra features, to install with:
# `pip install svg_removeoverlap[PDF]` like:
# PDF = ReportLab; RXP

# Add here test requirements (semicolon/line-separated)
testing =
    setuptools
    pytest
    pytest-cov

[options.entry_points]
# Add here console scripts like:
console_scripts =
     svg_removeoverlap = svg_removeoverlap.__main__:cli
# For example:
# console_scripts =
#     fibonacci = svg_removeoverlap.skeleton:run
# And any other entry points, for example:
# pyscaffold.cli =
#     awesome = pyscaffoldext.awesome.extension:AwesomeExtension

[devpi:upload]
# Options for the devpi: PyPI server and packaging tool
# VCS export must be deactivated since we are using setuptools-scm
no_vcs = 1
formats = bdist_wheel

[flake8]
# Some sane defaults for the code style checker flake8
max_line_length = 88
extend_ignore = E203, W503
# ^  Black-compatible
#    E203 and W503 have edge cases handled by black
exclude =
    .tox
    build
    dist
    .eggs
    docs/conf.py

[pyscaffold]
# PyScaffold's parameters when the project was created.
# This will be used when updating. Do not change!
version = 4.4
package = svg_removeoverlap
extensions =
    github_actions
    markdown
    no_skeleton
    no_tox
    pre_commit
</file>

<file path="setup.py">
"""
    Setup file for svg_removeoverlap.
    Use setup.cfg to configure your project.

    This file was generated with PyScaffold 4.4.
    PyScaffold helps you to put up the scaffold of your new Python project.
    Learn more under: https://pyscaffold.org/
"""
from setuptools import setup

if __name__ == "__main__":
    try:
        setup(use_scm_version={"version_scheme": "no-guess-dev"})
    except:  # noqa
        print(
            "\n\nAn error occurred while building the project, "
            "please ensure you have the most updated version of setuptools, "
            "setuptools_scm and wheel with:\n"
            "   pip install -U setuptools setuptools_scm wheel\n\n"
        )
        raise
</file>

</files>
